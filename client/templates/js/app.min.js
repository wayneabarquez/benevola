(function () {
    'use strict';

    angular
        .module('demoApp', ['ngMaterial', 'ngMessages', 'ngAnimate', 'restangular',
            'oitozero.ngSweetAlert', 'treasure-overlay-spinner', 'md.data.table',
            'angularMoment', 'angularInlineEdit', 'ngMaterialDatePicker'
        ])

        .constant('BASE_URL', window.location.origin)
        .constant('NAV_HEIGHT', 0)
        .constant('LOT_STATUSES', ['vacant', 'sold', 'occupied'])

        .config(["$mdThemingProvider", function ($mdThemingProvider) {
            $mdThemingProvider.theme('default')
                .primaryPalette('blue')
                .accentPalette('pink');
        }])

        //.config(['uiMask.ConfigProvider', function (uiMaskConfigProvider) {
        //    uiMaskConfigProvider.maskDefinitions({'*': /[xX0-9]/});
        ////    //uiMaskConfigProvider.clearOnBlur(false);
        ////    //uiMaskConfigProvider.eventsToHandle(['input', 'keyup', 'click']);
        //}])

        .config(['RestangularProvider', function (RestangularProvider) {
            //set the base url for api calls on our RESTful services
            RestangularProvider.setBaseUrl(window.location.origin + '/api');
        }]);

}());


(function(){
'use strict';

angular.module('demoApp')
    .factory('lotHelper', [lotHelper]);

    function lotHelper () {
        var service = {};

        service.computeArea = computeArea;
        service.filterDimensionString = filterDimensionString;

        function validateDimensionArray(dimensionArray) {
            var flag = true,
                lastChar = dimensionArray[0];

            if(isNaN(lastChar)) return false;

            for(var i=1; i < dimensionArray.length; i++) {
                if(isNaN(lastChar) && isNaN(dimensionArray[i])) {
                    flag = false;
                    return;
                }

                lastChar = dimensionArray[i];
            }

            return flag;
        }

        function filterDimensionArray (dimensionArray) {
            function removeNonNumeric(value) {
                return value.length && !isNaN(value);
            }
            return dimensionArray.filter(removeNonNumeric);
        }

        function filterDimensionString (dimension) {
            var dimensionArray = dimension.toLowerCase().split('x');
            return getDimensionString(filterDimensionArray(dimensionArray));
        }

        function getDimensionString(dimensionArray) {
            var dimension = '',
                len = dimensionArray.length;

            dimensionArray.forEach(function(value, index){
                if(index < len - 1) {
                    dimension += value + 'x';
                } else {
                    dimension += value;
                }
            });
            return dimension;
        }

        function computeArea (dimension) {
            if(!dimension) return false;

            var dimensionArray = dimension.toLowerCase().split('x');
            var filteredDimensionArray = filterDimensionArray(dimensionArray);

            if( !validateDimensionArray(dimensionArray)) return false;

            var dimensionStr = getDimensionString(filteredDimensionArray);

            var _area = filteredDimensionArray.length == 2
                     ? parseFloat(filteredDimensionArray[0] * filteredDimensionArray[1])
                     : null;

            //var _area = filteredDimensionArray[0];
            //for(var i=1; i < filteredDimensionArray.length; i++)
            //    _area *= filteredDimensionArray[i];

            dimensionStr += dimensionArray[dimensionArray.length - 1] == ""
                            ? 'x'
                            : '';

            return {
                dimension: dimensionStr,
                area: _area
            };
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('webServices', ["webRequest", webServices]);

    function webServices(webRequest) {
        var service = {};

        /*
        * Meters
        */
        //service.getMeters = function (zoomLevel) {
        //    return webRequest.get('/api/meters');
        //};
        //
        //service.getMeterClustersByZoom = function (zoomLevel) {
        //    return webRequest.get('/api/meters/clusters/zoom/' + zoomLevel);
        //};
        //
        //service.getMeterClustersByZoomAndBounds = function (zoomLevel, bounds) {
        //    return webRequest.get('/api/meters/clusters/zoom/' + zoomLevel + '/bounds/' + bounds);
        //};
        //
        //service.getMetersWithinBounds = function (bounds) {
        //    return webRequest.get('/api/meters/bounds/' + bounds);
        //};
        //
        //service.getMetersByID = function (id) {
        //    return webRequest.get('/api/meters/' + id);
        //};
        //
        //service.getMetersBounds = function () {
        //  return webRequest.get('/api/meters/get_bounds');
        //};
        //
        //service.getMeterByMeterNo = function (meterNo) {
        //    return webRequest.get('/api/meters/get_by_meter_no/' + meterNo);
        //}

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('sectionList', ['$rootScope', '$mdSidenav', 'gmapServices', 'Sections', 'blockList', sectionList]);

    function sectionList ($rootScope, $mdSidenav, gmapServices, Sections, blockList) {
        var service = {};

        service.polygoncolor = '#2c3e50';
        service.polygonOptions = {
            clickable: true,
            fillColor: service.polygoncolor,
            fillOpacity: 0,
            strokeColor: service.polygoncolor,
            strokeOpacity: 0.8,
            strokeWeight: 4,
            zIndex: 99
        };

        service.sections = [];

        service.loadSections = loadSections;
        service.add = add;

        function loadSections (loadForIndex) {
            var forIndex = loadForIndex || false;

            Sections.getList()
                .then(function(response){
                    response.forEach(function(section){
                        service.add(section, forIndex);
                    });
                }, function(error){
                    console.log('Error loading sections list: ',error);
                });
        }

        function add (sectionData, forIndex) {
            sectionData.polygon = createPolygon(sectionData, forIndex);

            blockList.loadBlocksForSection(sectionData, forIndex);

            service.sections.push(sectionData);
            return sectionData;
        }

        function createPolygon(section, forIndex) {
            var polygon = gmapServices.createCustomPolygon(section.area, service.polygonOptions);
                polygon.section = section;

            var adminHandler = function () {
                var sidenavId = 'sectionDetailsSidenav';
                $mdSidenav(sidenavId)
                    .open()
                    .then(function () {
                        $rootScope.$broadcast('show-section-details', {section: section});
                    });
            };

            var indexHandler = function () {
                console.log('section polygon is clicked handler for index');
                var sidenavId = 'sectionDetailsIndexSidenav';

                //if($mdSidenav(sidenavId).isOpen()) $mdSidenav(sidenavId).toggle();


                $mdSidenav(sidenavId)
                    .open()
                    .then(function () {
                        $rootScope.$broadcast('show-section-details', {section: section});
                    });
            };

            var handler = forIndex ? indexHandler : adminHandler;

            gmapServices.addListener(
                polygon,
                'click',
                function() {
                    gmapServices.setZoomIfGreater(21);
                    gmapServices.panToPolygon(polygon);
                    gmapServices.highlightPolygon(polygon);
                    handler();
                }
            );

            return polygon;
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('modalServices', ['$mdDialog', '$mdMedia', '$rootScope', '$q', 'Settings', 'Clients', modalServices]);

    function modalServices ($mdDialog, $mdMedia, $rootScope, $q, Settings, Clients) {
        var service = {};

        service.customFullscreen = $mdMedia('sm') || $mdMedia('xs');

        service.closeModal = closeModal;

        service.settingsModal = null;
        service.showSettings = showSettings;

        service.addSectionModal = null;
        service.addBlockModal = null;
        service.addLotModal = null;

        service.showAddSection = showAddSection;
        service.showAddBlock = showAddBlock;
        service.showAddLot = showAddLot;

        service.showLotDetailModal = null;
        service.showLotDetail = showLotDetail;

        service.showColumbaryDetailModal = null;
        service.showColumbaryDetail = showColumbaryDetail;

        service.showClientSelectionModal = null;
        service.showClientSelection = showClientSelection;

        service.showAddOccupantModal = null;
        service.showAddOccupant = showAddOccupant;

        service.salesReportModal = null;
        service.showSalesReport = showSalesReport;

        service.cremationListReportModal = null;
        service.showCremationListReport = showCremationListReport;

        service.showColumbaryListModal = null;
        service.showColumbaryList = showColumbaryList;

        var showColumbaryTableModal = null;
        service.showColumbaryTable = showColumbaryTable;

        var showCrematoriumModal = null;
        service.showCrematorium = showCrematorium;

        var showUpdateDeceasedModal = null;
        service.showUpdateDeceased = showUpdateDeceased;

        //var showNewCremationModal = null;
        //service.showNewCremation = showNewCremation;

        function showModal(modalObj, modalParams) {
            var dfd = $q.defer();
            if (modalObj) {
                dfd.reject("Modal already opened");
            } else {
                $rootScope.$broadcast("modal-opened");
                modalObj = $mdDialog.show(modalParams);
                modalObj.then(function (result) {
                        dfd.resolve(result);
                    }, function (reason) {
                        $rootScope.$broadcast("modal-dismissed");
                        dfd.reject(reason);
                    })
                    .finally(function () {
                        modalObj = null;
                    });
            }
            return dfd.promise;
        }

        function showSettings(ev) {
            var dfd = $q.defer();

            Settings.customGET('last_lot_price')
                .then(function(lastLot) {
                    console.log('get last lot price: ', lastLot);
                    var opts = {
                        controller: 'settingsController',
                        controllerAs: 'settingsCtl',
                        templateUrl: 'partials/modals/settings_dialog.tmpl.html',
                        parent: angular.element(document.body),
                        targetEvent: ev,
                        locals: {lastLot: lastLot},
                        fullscreen: service.customFullscreen
                    };
                    dfd.resolve(showModal(service.settingsModal, opts));
                },function(error){ dfd.reject(error); });

            return dfd.promise;
        }

        function showAddSection(event, sectionArea) {
            var opts = {
                controller: 'addSectionController',
                controllerAs: 'addSectionCtl',
                templateUrl: 'partials/modals/add_section_dialog.tmpl.html',
                parent: angular.element(document.body),
                locals: {area: sectionArea},
                targetEvent: event,
                fullscreen: service.customFullscreen
            };

            return showModal(service.addSectionModal, opts);
        }

        function showAddBlock(event, section, sectionArea) {
            var opts = {
                controller: 'addBlockController',
                controllerAs: 'addBlockCtl',
                templateUrl: 'partials/modals/add_block_dialog.tmpl.html',
                parent: angular.element(document.body),
                locals: {section: section, area: sectionArea},
                targetEvent: event,
                fullscreen: service.customFullscreen
            };

            return showModal(service.addBlockModal, opts);
        }

        function showAddLot(event, block, area) {
            var opts = {
                controller: 'addLotController',
                controllerAs: 'addLotCtl',
                templateUrl: 'partials/modals/add_lot_dialog.tmpl.html',
                parent: angular.element(document.body),
                locals: {block: block, area: area},
                targetEvent: event,
                fullscreen: service.customFullscreen
            };

            return showModal(service.addLotModal, opts);
        }

        function showLotDetail(lot) {
            var dfd = $q.defer();
            console.log('Show Lot Detail: ', lot);

            lot.get()
                .then(function (result) {
                    var opts = {
                        controller: 'lotDetailsController',
                        controllerAs: 'lotDetsCtl',
                        templateUrl: 'partials/modals/lot_details_dialog.tmpl.html',
                        parent: angular.element(document.body),
                        locals: {lot: result},
                        fullscreen: service.customFullscreen
                    };

                    dfd.resolve(showModal(service.showLotDetailModal, opts));
            },function(error){dfd.reject(error);});

            return dfd.promise;
        }

        function showClientSelection (lot) {
            var dfd = $q.defer();

            Clients.getList()
                .then(function (resp) {
                    var clients = [];
                    resp.forEach(function (cl) {
                        clients.push(cl);
                    });

                    var opts = {
                        controller: 'clientSelectionController',
                        controllerAs: 'clientSelectCtl',
                        templateUrl: 'partials/modals/lot_client_select_dialog.tmpl.html',
                        parent: angular.element(document.body),
                        locals: {lot: lot, clients: clients},
                        fullscreen: service.customFullscreen
                    };

                    dfd.resolve(showModal(service.showClientSelectionModal, opts));
            }, function (error) {
                dfd.reject(error);
            });

            return dfd.promise;
        }

        function showAddOccupant (lot) {
            var opts = {
                controller: 'addLotOccupantController',
                controllerAs: 'addLotOcptCtl',
                templateUrl: 'partials/modals/add_lot_occupant_dialog.tmpl.html',
                parent: angular.element(document.body),
                locals: {lot: lot},
                fullscreen: service.customFullscreen
            };

            return showModal(service.showAddOccupantModal, opts);
        }

        function showSalesReport () {
            var opts = {
                controller: 'salesReportController',
                controllerAs: 'salesRepCtl',
                templateUrl: 'partials/modals/sales_report_dialog.tmpl.html',
                parent: angular.element(document.body),
                fullscreen: service.customFullscreen
            };

            return showModal(service.salesReportModal, opts);
        }

        function showCremationListReport () {
            var opts = {
                controller: 'cremationListReportController',
                controllerAs: 'clr',
                templateUrl: 'partials/modals/cremation_list_report_dialog.tmpl.html',
                parent: angular.element(document.body),
                fullscreen: service.customFullscreen
            };

            return showModal(service.cremationListReportModal, opts);
        }

        function showColumbaryList(event) {
            var opts = {
                controller: 'columbaryListController',
                controllerAs: 'cListCtl',
                templateUrl: 'partials/modals/columbary_list.tmpl.html',
                parent: angular.element(document.body),
                fullscreen: service.customFullscreen,
                targetEvent: event
            };

            return showModal(service.showColumbaryListModal, opts);
        }

        function showColumbaryDetail(columbary) {
            var dfd = $q.defer();

            columbary.get()
                .then(function (result) {
                    var opts = {
                        controller: 'columbaryDetailsController',
                        controllerAs: 'cDetsCtl',
                        templateUrl: 'partials/modals/columbary_details_dialog.tmpl.html',
                        parent: angular.element(document.body),
                        locals: {columbary: result},
                        fullscreen: service.customFullscreen
                    };

                    dfd.resolve(showModal(service.showColumbaryDetailModal, opts));
                }, function (error) {
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function showColumbaryTable () {
            var opts = {
                controller: 'columbaryTableController',
                controllerAs: 'cTblCtl',
                templateUrl: 'partials/modals/columbary_table.tmpl.html',
                parent: angular.element(document.body),
                fullscreen: service.customFullscreen
            };

            return showModal(showColumbaryTableModal, opts);
        }

        function showCrematorium () {
            var opts = {
                controller: 'crematoriumListController',
                controllerAs: 'cremListCtl',
                templateUrl: 'partials/modals/crematorium_table.tmpl.html',
                parent: angular.element(document.body),
                fullscreen: service.customFullscreen
            };

            return showModal(showCrematoriumModal, opts);
        }

        //function showNewCremation (event) {
        //    var opts = {
        //        controller: 'newCremationController',
        //        controllerAs: 'newCremCtl',
        //        templateUrl: 'partials/modals/new_cremation.tmpl.html',
        //        parent: angular.element(document.body),
        //        fullscreen: service.customFullscreen,
        //        targetEvent: event
        //    };
        //
        //    return showModal(showNewCremationModal, opts);
        //}

        function showUpdateDeceased (deceased) {
            var opts = {
                controller: 'updateDeceasedController',
                controllerAs: 'vm',
                templateUrl: 'partials/modals/update_deceased.tmpl.html',
                parent: angular.element(document.body),
                locals: {deceased: deceased},
                fullscreen: service.customFullscreen
            };

            return showModal(showUpdateDeceasedModal, opts);
        }

        function closeModal() {
            $mdDialog.cancel();
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('lotList', ['$rootScope', 'gmapServices', 'LOT_COLORS', 'drawingServices', 'modalServices', 'Blocks', 'Lots', 'alertServices', lotList]);

    function lotList ($rootScope, gmapServices, LOT_COLORS, drawingServices, modalServices, Blocks, Lots, alertServices) {
        var service = {};

        service.selectedLotInfowindow = gmapServices.createInfoWindow('');

        service.polygonColor = LOT_COLORS;
        service.polygonOptions = {
            clickable: true,
            fillOpacity: 0.8,
            strokeColor: '#000000',
            strokeOpacity: 0.6,
            strokeWeight: 1,
            zIndex: 101
        };

        service.lots = [];

        service.loadLotsForBlock = loadLotsForBlock;
        service.add = add;
        service.findLot = findLot;
        service.togglePolygonByStatus = togglePolygonByStatus;
        service.showLotDetailsModal = showLotDetailsModal;

        function initialize() {

            $rootScope.$on('update-lot-detail', function(event, params) {
               var lot = params.lot;

                console.log('Update Lot Detail Event: ', lot);

                var foundLot = service.findLot(lot.block_id, lot.id);
                foundLot.status = lot.status;

                var polygonColor = service.polygonColor[lot.status];
                var polygonOpts = angular.extend({}, service.polygonOptions, {
                    fillColor: polygonColor
                });
                foundLot.polygon.setOptions(polygonOpts);
            });

            $('body').on('click', '.admin-delete-lot-button', function () {
                var lotId = $(this).data('lot-id');
                console.log('delete lot with id = ', lotId);
            });

            $(document).on('click', '.show-lot-detail-button', function () {
                var lotId = $(this).data('lot-id'),
                    blockId = $(this).data('block-id');

                var foundLot = service.findLot(blockId, lotId);

                if (foundLot) {
                    service.showLotDetailsModal(foundLot);
                }
            });
        }

        initialize();

        function loadLotsForBlock (block, forIndex) {
            if(!block.lots) return;

            block.lots.forEach(function(lot){
                service.add(block, lot, forIndex);
            });
        }

        function findLot(blockId, lotId) {
            return _.findWhere(service.lots, {id: lotId, block_id: blockId});
        }

        function add (block, data, forIndex) {
            //if (!service.lots[blockId]) service.lots[blockId] = [];

            //var blockId = block.id;
            data.section_id = block.section_id;
            data.amount = data.lot_area * data.price_per_sq_mtr;
            data.client_name = data.client && data.client.last_name
                               ? (data.client.first_name + ' ' + data.client.last_name)
                               : '';

            data.date_purchased_formatted = data.date_purchased
                                            ? moment(data.date_purchased).format("MMM DD, YYYY")
                                            : '';

            data.polygon = createPolygon(data, forIndex);

            //service.lots[blockId].push(data);
            service.lots.push(data);
        }

        function createPolygon(lot, forIndex) {
            var polygonColor = service.polygonColor[lot.status];
            var polygonOpts = angular.extend({}, service.polygonOptions, {
               fillColor: polygonColor
            });
            var polygon = gmapServices.createCustomPolygon(lot.area, polygonOpts);

            Lots.cast(lot);

            var adminHandler = function (_lot) {
                var content = '<div style="min-height: 45px;">';
                content += '<button data-lot-id="' + _lot.id + '" class="md-raised md-button md-primary md-hue-2 md-icon-button md-ink-ripple" id="admin-duplicate-lot-button" type="button"><i class="material-icons">content_copy</i></button>';
                content += '<button data-lot-id="' + _lot.id + '" class="md-raised md-button md-primary md-icon-button md-ink-ripple" id="admin-update-lot-polygon-button" type="button"><i class="material-icons">format_shapes</i></button>';
                content += '<button data-lot-id="'+_lot.id+'" class="md-raised md-button md-warn md-icon-button md-ink-ripple" id="admin-delete-lot-button" type="button"><i class="material-icons">delete</i></button>';
                content += '</div>';

                var center = gmapServices.getPolygonCenter(lot.polygon);
                gmapServices.showInfoWindow(service.selectedLotInfowindow);
                service.selectedLotInfowindow.setPosition(center);
                service.selectedLotInfowindow.setContent(content);

                $('#admin-delete-lot-button').click(function () {
                    var polygonTemp = _lot.polygon;

                    _lot.polygon = null;

                    _lot.remove()
                        .then(function(s){
                            gmapServices.hidePolygon(polygonTemp);
                            polygonTemp = null;
                        },function(e){
                           _lot.polygon = polygonTemp;
                           alertServices.showErrorMessage('Failed to Delete Lot');
                        })
                        .finally(function(){
                            gmapServices.hideInfoWindow(service.selectedLotInfowindow);
                        });
                });

                 $('#admin-duplicate-lot-button').click(function () {
                     // terminate infowindow
                     service.selectedLotInfowindow.close();

                    drawingServices.duplicateLot(_lot);

                     var duplicateListener = $rootScope.$on('save-duplicate', function (event, params) {
                        modalServices.showAddLot(event, null, params.path)
                            .then(function (result) {
                                //console.log('success: ', result);

                                var block = Blocks.cast(result.lot.block);
                                service.add(block, result.lot);

                                // todo
                                //block.lots.push(result.lot);
                            }, function (reason) {
                                console.log('failed: ', reason);
                            })
                            .finally(function () {
                                // destroy listener
                                duplicateListener();
                                duplicateListener = null;
                            });
                    });
                });

                $('#admin-update-lot-polygon-button').click(function () {
                    // terminate infowindow
                    service.selectedLotInfowindow.close();

                    var oldPath = angular.copy(_lot.polygon.getPath());

                    _lot.polygon.setOptions({
                        draggable: true,
                        editable: true
                    });

                    drawingServices.updateLotPolygon = _lot.polygon;

                    $rootScope.$broadcast('duplicate-complete');

                    var updateListener = $rootScope.$on('save-lot-polygon', function(e, params){
                        var path = params.path;
                        var tempPolygon = _lot.polygon;
                        _lot.polygon = null;
                        _lot.area = path;

                        _lot.put()
                            .then(function(response){
                                //console.log('response: ', response);
                                _lot.polygon = tempPolygon;
                                tempPolygon = null;
                                var opts = angular.merge({
                                    draggable: false,
                                    editable: false,
                                    path: response.lot.area
                                }, service.polygonOptions);
                                _lot.polygon.setOptions(opts);

                                $rootScope.$broadcast('end-drawing');

                            },function(error){
                               console.log('error: ',error);
                            })
                            .finally(function(){
                                updateListener();
                                updateListener = null;
                            });
                    });

                    $rootScope.$on('stop-drawing', function(){
                        var oldOpts = angular.merge({
                            draggable: false,
                            editable: false,
                            path: oldPath
                        }, service.polygonOptions);
                        _lot.polygon.setOptions(oldOpts);
                    });
                });
            };

            polygon.lot = lot;

            var indexHandler = function (_lot) {
                showLotInfowindow(_lot);
            };

            var handler = forIndex ? indexHandler : adminHandler;

            gmapServices.addListener(polygon, 'click', function() {
                gmapServices.setZoomIfGreater(21);
                gmapServices.panToPolygon(polygon);
                handler(this.lot);
            });

            return polygon;
        }

        function togglePolygon(value, polygon) {
            if (value) {
                gmapServices.showPolygon(polygon);
            } else {
                gmapServices.hidePolygon(polygon);
            }
        }

        function showLotDetailsModal (lot) {
            modalServices.showLotDetail(lot)
                .then(function (response) {
                }, function (err) {
                });
        }

        function togglePolygonByStatus(_status, _value) {
            if(_status === 'all') {
                service.lots.forEach(function (lot) {
                    togglePolygon(_value, lot.polygon);
                });
                return;
            }

            var lots = _.where(service.lots, {status: _status});

            lots.forEach(function(lot){
                togglePolygon(_value, lot.polygon);
            });
        }

        var lotInfowindow = gmapServices.createInfoWindow('');

        function showLotInfowindow(lot) {
            var info = '<b>Lot:</b> ' + (lot.name ? lot.name : 'undefined') + ' <br>';
            info += '<b>Section:</b> ' + lot.block.section.name + ' <br>';
            info += '<b>Block:</b> ' + lot.block.name + ' <br>';
            info += '<b>Area:</b> ' + lot.lot_area + ' <br>';
            info += '<b>Amount:</b> ' + lot.amount + ' <br>';
            info += '<b>Status:</b> <span class="' + lot.status + '">' + lot.status + '</span> <br>';
            info += '<b>Date Purchased:</b> ' + lot.date_purchased_formatted + ' <br>';
            info += '<button data-lot-id="' + lot.id + '" data-block-id="' + lot.block_id + '" class="show-lot-detail-button md-primary md-button md-raised">Show Details</button>';

            var center = gmapServices.getPolygonCenter(lot.polygon);
            gmapServices.showInfoWindow(lotInfowindow);
            gmapServices.panTo(center);

            lotInfowindow.setPosition(center);
            lotInfowindow.setContent(info);
        }


        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('loaderServices', ['$rootScope', loaderServices]);

    function loaderServices ($rootScope) {
        var service = {};

        service.showLoader = showLoader;
        service.hideLoader = hideLoader;

        function showLoader () {
            $rootScope.spinner.active = true;
        }

        function hideLoader (_doApply) {
            var doApply = _doApply || false;
            if(doApply) {
                $rootScope.$apply(function () {
                    $rootScope.spinner.active = false;
                });
            } else {
                $rootScope.spinner.active = false;
            }
        }
        

        return service;
    }
}());
(function(){
    'use strict';

    angular.module('demoApp')
        .factory('gmapServices', ['$log', '$q', '$timeout', gmapServices]);

    function gmapServices($log, $q, $timeout) {
        var service = {};

        //infowindow balloons
        service.INFO_WINDOWS = [];

        service.ZOOM_OUT_LEVEL = 8;
        service.ZOOM_IN_LEVEL = 19;

        service.map = null;
        service.mapProjection = null;
        service.overlayView = null;

        service.geocoder = null;

        service.markers = [];

        service.defaultZoom = service.ZOOM_IN_LEVEL;

        service.centerLatLng = new google.maps.LatLng(10.382237, 123.955110);

        // Cluster Objects
        // for Different Layers
        service.markerClusterers = {};

        // Maintain only one infobox
        // Prevent from opening multiple infoboxes
        service.lastInfoboxOpen = null;
        service.infoboxes = [];

        /**
         * Service Functions
         */
        service.apiAvailable = apiAvailable;
        service.createMap = createMap;
        service.createInfoBox = createInfoBox;
        service.openInfoBox = openInfoBox;
        service.closeInfoBox = closeInfoBox;
        service.closeAllInfoBox = closeAllInfoBox;
        service.setMapCursorCrosshair = setMapCursorCrosshair;
        service.setMapBounds = setMapBounds;
        service.getBoundsFromPath = getBoundsFromPath;
        service.setMapCursorDefault = setMapCursorDefault;
        service.addMapListener = addMapListener;
        service.getDistanceOfPath = getDistanceOfPath;
        service.fromLatLngToContainerPixel = fromLatLngToContainerPixel;
        service.fromLatLngToDivPixel = fromLatLngToDivPixel;
        service.fromLatLngToPoint = fromLatLngToPoint;
        service.createCoordinate = createCoordinate;
        service.createInfoWindow = createInfoWindow;
        service.createCanvasInfoWindow = createCanvasInfoWindow;
        service.hideCanvasInfoWindow = hideCanvasInfoWindow;
        service.showInfoWindow = showInfoWindow;
        service.hideInfoWindow = hideInfoWindow;
        service.clearInstanceListeners = clearInstanceListeners;
        service.initMarker = initMarker;
        service.createMarker = createMarker;
        service.createCustomMarker = createCustomMarker;
        service.createCircleMarker = createCircleMarker;
        service.panTo = panTo;
        service.panToOffsetLeft = panToOffsetLeft;
        service.showMarker = showMarker;
        service.showMarkers = showMarkers;
        service.hideMarker = hideMarker;
        service.hideMarkers = hideMarkers;
        service.destroyMarker = destroyMarker;
        service.destroyPolyline = destroyPolyline;
        service.centerMarker = centerMarker;
        service.setMapCenter = setMapCenter;
        service.setMapCenterDefault = setMapCenterDefault;
        service.setZoom = setZoom;
        service.setZoomIfGreater = setZoomIfGreater;
        service.setZoomDefault = setZoomDefault;
        service.setZoomInDefault = setZoomInDefault;
        service.createDrawingManager = createDrawingManager;
        service.createDrawingToolsManager = createDrawingToolsManager;
        service.showDrawingManager = showDrawingManager;
        service.hideDrawingManager = hideDrawingManager;
        service.setEnableDrawingManager = setEnableDrawingManager;
        service.changeDrawingManagerStrokeColor = changeDrawingManagerStrokeColor;
        service.createCircle = createCircle;
        service.updateCircle = updateCircle;
        service.initPolygon = initPolygon;
        service.createPolygon = createPolygon;
        service.createCustomPolygon = createCustomPolygon;
        service.updatePolygon = updatePolygon;
        service.showPolygon = showPolygon;
        service.hidePolygon = hidePolygon;
        service.resetPolygonFill = resetPolygonFill;
        service.fillPolygon = fillPolygon;
        service.getPolygonCenter = getPolygonCenter;
        service.panToPolygon = panToPolygon;
        service.setEditablePolygon = setEditablePolygon;
        service.createPolyline = createPolyline;
        service.createDashedPolyline = createDashedPolyline;
        service.updatePolyline = updatePolyline;
        service.showPolyline = showPolyline;
        service.hidePolyline = hidePolyline;
        service.addListener = addListener;
        service.addListenerOnce = addListenerOnce;
        service.clearInstanceListeners = clearInstanceListeners;
        service.clearListeners = clearListeners;
        service.removeListener = removeListener;
        service.trigger = trigger;
        service.showCurrentLocation = showCurrentLocation;
        service.reverseGeocode = reverseGeocode;
        service.loadKMLByURL = loadKMLByURL;
        service.initMapClusterer = initMapClusterer;
        service.destroyMapClusterer = destroyMapClusterer;
        service.createClusterMarker = createClusterMarker;
        service.getClustererInstance = getClustererInstance;
        service.clearClusterMarkers = clearClusterMarkers;
        service.resetClusters = resetClusters;
        service.insertImageMapType = insertImageMapType;
        service.removeOverlayAtIndex = removeOverlayAtIndex;
        service.initializeAutocomplete = initializeAutocomplete;
        service.containsLocation = containsLocation;
        service.triggerEvent = triggerEvent;
        service.highlightPolygon = highlightPolygon;

        function apiAvailable() {
            return typeof window.google === 'object';
        }

        function createMap(mapId, navHeight) {
            var _navHeight = navHeight || 0;

            var mapIdLoc = mapId || 'map3d';
            var myMapId = '#' + mapIdLoc;

            if (service.map) return service.map;
            if (!service.apiAvailable()) return null;

            var mapOptions = {
                zoom: service.defaultZoom,
                minZoom: 2,
                center: service.centerLatLng,
                mapTypeControl: false,
                mapTypeId: google.maps.MapTypeId.HYBRID,
                zoomControlOptions: {
                    position: google.maps.ControlPosition.RIGHT_BOTTOM
                },
                panControl: false,
                streetViewControl: false
            };

            $(myMapId).height($(window).height() - (_navHeight));

            service.map = new google.maps.Map(document.getElementById(mapIdLoc), mapOptions);

            // handle window resize event
            google.maps.event.addDomListener(window, 'resize', function () {
                $(myMapId).height($(window).height() - (_navHeight));
                var center = service.map.getCenter();
                google.maps.event.trigger(service.map, 'resize');
                service.map.setCenter(center);
            });

            return service.map;
        }

        function createInfoBox(template) {
            return new InfoBox({
                content: template || '',
                disableAutoPan: true,
                maxWidth: 0,
                pixelOffset: new google.maps.Size(25, -115),
                //closeBoxMargin: '15px 5px',
                closeBoxURL: 'static/resources/images/close-icon.png',
                isHidden: false,
                pane: 'floatPane',
                enableEventPropagation: true
            });
        }

        function openInfoBox(infobox, marker) {
            if( !(service.map && infobox && marker)) return;

            // Close last infobox open
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();

            infobox.open(service.map, marker);

            service.lastInfoboxOpen = infobox;
            service.infoboxes.push(infobox);
        }

        function closeAllInfoBox() {
            service.infoboxes.forEach(function(infobox, index) {
               if(infobox) {
                   infobox.close();
               }
            });
        }

        function closeInfoBox() {
            if (service.lastInfoboxOpen) service.lastInfoboxOpen.close();
        }

        function addMapListener(eventName, callback) {
            if (service.map) {
                return service.addListener(service.map, eventName, callback);
            }
            return null;
        }

        function setMapCursorDefault() {
            if (service.map) service.map.setOptions({draggableCursor: null});
        }

        function setMapCursorCrosshair() {
            if (service.map) service.map.setOptions({draggableCursor: 'crosshair'});
        }

        function setMapBounds(bounds) {
            if (service.map) service.map.fitBounds(bounds);
        }

        function getBoundsFromPath(path) {
            if (!service.apiAvailable()) return null;
            var bounds = new google.maps.LatLngBounds();
            for (var index = 0; index < path.length; index++) {
                var point = path[index];
                bounds.extend(point);
            }
            return bounds;
        }

        function getDistanceOfPath(path) {
            if (!service.apiAvailable()) return 0;
            return google.maps.geometry.spherical.computeLength(path);
        }

        function fromLatLngToContainerPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToContainerPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToDivPixel(latlng) {
            if (service.overlayView) {
                return service.overlayView.getProjection().fromLatLngToDivPixel(latlng);
            }
            return new google.maps.Point();
        }

        function fromLatLngToPoint(latlng) {
            if (service.map) {
                var numTiles = 1 << service.map.getZoom();
                var projection = new MercatorProjection();
                var worldCoordinate = projection.fromLatLngToPoint(latlng);
                return new google.maps.Point(
                    worldCoordinate.x * numTiles,
                    worldCoordinate.y * numTiles
                );
            } else {
                return new google.maps.Point();
            }
        }

        function createCoordinate(latitude, longitude) {
            return new google.maps.LatLng(latitude, longitude);
        }

        function createInfoWindow(content) {
            if (!service.apiAvailable()) return null;
            return new google.maps.InfoWindow({content: content});
        }

        function createCanvasInfoWindow() {
            if (!service.apiAvailable()) return null;

            return new CanvasInfoWindow(service.map);
        }

        function hideCanvasInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.hideInfowindow();
        };

        function showInfoWindow(infoWindow, target) {
            if (infoWindow) infoWindow.open(service.map, target);
        }

        function hideInfoWindow(infoWindow) {
            if (infoWindow) infoWindow.close();
        }

        function clearInstanceListeners(_instance) {
            google.maps.event.clearInstanceListeners(_instance);
        }

        function initMarker(_position, _icon, _opts) {
            if (!service.apiAvailable()) return null;

            var additionalOpts = _opts || {};

            var opts = angular.extend({}, {
                position: _position,
                map: service.map,
                icon: _icon
            }, additionalOpts);

            return new google.maps.Marker(opts);
        }

        function createMarker(_position, _color) {
            _color = _color || service.MARKER_ICONS.RED;
            var marker = service.initMarker(_position, _color);

            service.markers.push(marker);

            return marker;
        }

        function createCustomMarker(_position, _icon, _opts) {
            var opts = _opts || {},
                icon = _icon || 'images/markers/default-marker.png';

            return service.initMarker(_position, icon, opts);
        }

        function createCircleMarker(_position, color) {
            var icon = {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 5,
                fillColor: color || '#6ac1ff',
                fillOpacity: 1,
                strokeColor: 'black',
                strokeWeight: 1
            };

            var marker = service.initMarker(_position, icon);
            service.markers.push(marker);

            return marker;
        }

        function panTo(_position) {
            if (!service.map) return;

            service.map.panTo(_position);
        }

        function panToOffsetLeft(_position, _offset) {
            var offset = _offset || 0.013;
            var latLng = {};

            if(_position instanceof google.maps.LatLng) {
                console.log('object latlng');
                latLng.lat = _position.lat();
                latLng.lng = _position.lng() + offset;
            } else{
                latLng = _position;
                latLng.lng += offset;
            }

            this.panTo(latLng);
        }

        function showMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(service.map);
        }

        function showMarkers(markerArray) {
            markerArray.forEach(function (marker) {
                service.showMarker(marker);
            });
        }

        function hideMarker(marker) {
            if (marker && marker instanceof google.maps.Marker) marker.setMap(null);
        }

        function hideMarkers(markerArray) {
            markerArray.forEach( function(marker) {
                service.hideMarker(marker);
            });
        }

        function destroyPolyline(polyline) {
            if (polyline && polyline instanceof google.maps.Polyline) polyline.setMap(null);
            service.clearInstanceListeners(polyline);
            polyline = null;
        }

        function destroyMarker(marker) {
            if (marker instanceof Cluster) {
                marker.remove();
            }
            else if (marker instanceof google.maps.Marker) {
                service.hideMarker(marker);
                service.clearInstanceListeners(marker);
            }
            marker = null;
        }

        function centerMarker(marker) {
            if (service.map) {
                service.map.setCenter(marker.position);
            }
        }

        function setMapCenter(coordinates) {
            if (service.map) {
                service.map.setCenter(coordinates);
            }
        }

        function setMapCenterDefault() {
            service.setMapCenter(service.centerLatLng);
        }

        function setZoom(zoomValue) {
            if (service.map) {
                service.map.setZoom(zoomValue);
            }
        }

        function setZoomIfGreater(zoomValue) {
            if (zoomValue > service.map.getZoom())
                service.setZoom(zoomValue);
        }

        function setZoomDefault() {
            service.setZoom(service.defaultZoom);
        }

        function setZoomInDefault() {
            service.setZoom(service.ZOOM_IN_LEVEL);
        }

        function createDrawingManager(_color) {
            if (!service.apiAvailable()) return null;

            var strokeColor = _color || '#0000ff';

            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                polygonOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    geodesic: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: true,
                    editable: true,
                    fillColor: '#ffffff',
                    fillOpacity: 0,
                    strokeColor: strokeColor,
                    strokeOpacity: 0.9,
                    strokeWeight: 2,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function changeDrawingManagerStrokeColor (color) {
            if (!service.apiAvailable() && !service.drawingManager) return null;

            var _color = color || '#0000ff';

            service.drawingManager.setOptions({
                polygonOptions: {
                    strokeColor: _color
                },
                rectangleOptions: {
                    strokeColor: _color
                }
            });

        }

        function createDrawingToolsManager() {
            if (!service.apiAvailable()) return null;
            var drawingManager = new google.maps.drawing.DrawingManager({
                drawingMode: null,
                drawingControl: true,
                drawingControlOptions: {
                    position: google.maps.ControlPosition.TOP_CENTER,
                    drawingModes: [
                        google.maps.drawing.OverlayType.MARKER,
                        google.maps.drawing.OverlayType.CIRCLE,
                        google.maps.drawing.OverlayType.POLYGON,
                        google.maps.drawing.OverlayType.POLYLINE,
                        google.maps.drawing.OverlayType.RECTANGLE
                    ]
                },
                markerOptions: {
                    icon: service.MARKER_ICONS.RED
                },
                circleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polygonOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    geodesic: true,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                polylineOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                },
                rectangleOptions: {
                    clickable: true,
                    draggable: false,
                    editable: false,
                    fillColor: '#0000ff',
                    fillOpacity: 0.2,
                    strokeColor: '#0000ff',
                    strokeOpacity: 0.8,
                    strokeWeight: 1,
                    zIndex: 1
                }
            });
            service.drawingManager = drawingManager;
            return drawingManager;
        }

        function showDrawingManager(drawingManager) {
            if (drawingManager) {
                if(!drawingManager.getMap()) {
                    drawingManager.setMap(service.map);
                }
                service.setEnableDrawingManager(drawingManager, true);
            }
        }

        function hideDrawingManager(drawingManager) {
            if (drawingManager) {
                drawingManager.setMap(null);
                service.setEnableDrawingManager(drawingManager, false);
            }
        }

        function setEnableDrawingManager(drawingManager, enabled) {
            if (drawingManager) {
                var drawingOptions = {drawingControl: enabled};
                // if drawing mode is disabled, set current mode to hand pointer.
                if (!enabled) drawingOptions['drawingMode'] = null;
                drawingManager.setOptions(drawingOptions);
            }
        }

        function createCircle(latitude, longitude, radius) {
            if (!service.apiAvailable()) return null;
            var latlng = new google.maps.LatLng(latitude, longitude);
            var circleOptions = {
                center: latlng,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: '#ffffff',
                fillOpacity: 0,
                map: service.map,
                radius: radius,
                strokeColor: '#0000ff',
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Circle(circleOptions);
        }

        function updateCircle(circle, latitude, longitude, radius) {
            if (circle) {
                circle.setCenter({lat: latitude, lng: longitude});
                circle.setRadius(radius);
            }
        }

        function initPolygon(path, color) {
            if (!service.apiAvailable()) return null;

            var defaultColor = color || '#0000ff';
            var polygonOptions = {
                path: path,
                clickable: false,
                draggable: false,
                editable: false,
                fillColor: defaultColor,
                fillOpacity: 0,
                strokeColor: defaultColor,
                strokeOpacity: 0.9,
                strokeWeight: 2,
                zIndex: 100
            };

            return new google.maps.Polygon(polygonOptions);
        }

        function createCustomPolygon(path, opts) {
            var _opts = {
                path: path,
                map: service.map
            };
            angular.merge(_opts, opts);
            return new google.maps.Polygon(_opts);
        }

        function createPolygon(path, color) {
            var polygon = service.initPolygon(path, color);

            polygon.setMap(service.map);

            return polygon;
        }

        function updatePolygon(polygon, path) {
            if (polygon) polygon.setPath(path);
        }

        function showPolygon(polygon) {
            if (polygon) polygon.setMap(service.map);
        }

        function hidePolygon(polygon) {
            if (polygon) polygon.setMap(null);
        }

        function resetPolygonFill(polygon) {
            polygon.setOptions({
                fillOpacity: 0
            });
        }

        function fillPolygon(polygon) {
            polygon.setOptions({
                fillOpacity: 0.5
            });
        }

        function getPolygonCenter(polygon) {
            if (!service.map || !polygon) return;

            var bounds = new google.maps.LatLngBounds();

            polygon.getPath().forEach(function (path) {
                bounds.extend(path);
            });

            return bounds.getCenter();
        }

        function panToPolygon(polygon) {
            var center = service.getPolygonCenter(polygon);

            service.panTo(center);
        }

        function setEditablePolygon (polygon, flag) {
            var isEditable = flag !== false;

            console.log('polygon: ',polygon);

            polygon.setOptions({editable: isEditable, draggable: isEditable});
        }

        function createPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;
            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                strokeOpacity: 1,
                strokeWeight: 2,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function createDashedPolyline(path, lineColor) {
            if (!service.apiAvailable()) return null;

            var lineSymbol = {
                path: 'M 0,-1 0,1',
                strokeOpacity: 1,
                scale: 1
            };

            var polylineOptions = {
                path: path,
                clickable: true,
                draggable: false,
                editable: false,
                map: service.map,
                strokeColor: lineColor || '#ff0000',
                icons: [{
                    icon: lineSymbol,
                    offset: '0',
                    repeat: '3px'
                }],
                strokeOpacity: 0,
                zIndex: 100
            };
            return new google.maps.Polyline(polylineOptions);
        }

        function updatePolyline(polyline, path) {
            if (polyline) polyline.setPath(path);
        }

        function showPolyline(polyline) {
            if (polyline) polyline.setMap(service.map);
        }

        function hidePolyline(polyline) {
            if (polyline) polyline.setMap(null);
        }

        function addListener(instance, eventName, handler) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListener(instance, eventName, handler);
        }

        function addListenerOnce(instance, eventName, handler, capture) {
            if (!service.apiAvailable()) return null;
            return google.maps.event.addListenerOnce(instance, eventName, handler, capture);
        }

        function clearInstanceListeners(instance) {
            if (service.apiAvailable())
                google.maps.event.clearInstanceListeners(instance);
        }

        function clearListeners(instance, eventName) {
            if (service.apiAvailable())
                google.maps.event.clearListeners(instance, eventName);
        }

        function removeListener(listener) {
            if (service.apiAvailable())
                google.maps.event.removeListener(listener);
        }

        function trigger(instance, eventName, args) {
            if (service.apiAvailable())
                google.maps.event.trigger(instance, eventName, args);
        }

        function showCurrentLocation(_latLng, _isDraggable) {
            var icon = '/images/markers/current-location.png';
            var isDraggable = _isDraggable || false;

            return service.createCustomMarker(_latLng, icon, {draggable: isDraggable});
        }

        function reverseGeocode(latLng) {
            if (!service.geocoder) return;

            var dfd = $q.defer();

            service.geocoder.geocode({'latLng': latLng}, function (results, status) {
                if (status == google.maps.GeocoderStatus.OK) {
                    dfd.resolve(results);
                } else {
                    var error = "Geocoder failed due to: " + status;
                    $log.error(error);
                    dfd.reject(error);
                }
            });

            return dfd.promise;
        }

        function loadKMLByURL(srcUrl, kmlOptions) {
            if (service.map) {
                var opt = {
                    url: srcUrl,
                    map: service.map,
                    preserveViewport: true
                };

                if (kmlOptions) {
                    opt = angular.extend({}, opt, kmlOptions);
                }

                return new google.maps.KmlLayer(opt);
            }
            return null;
        }

        function loadClusterStyles(layerName) {
            var defaultStyle = 'resources/images/cluster_icons/m';

            if(layerName == 'meters') {
                return defaultStyle;
            } else if(layerName == 'transformers') {
                return 'resources/images/cluster_icons/transformers/m';
            } else if(layerName == 'poles') {
                return 'resources/images/cluster_icons/poles/m';
            }
            return defaultStyle;
        }

        function initMapClusterer(layerName) {
            if (!service.markerClusterers[layerName]) {
                var clusterStyle = loadClusterStyles(layerName);

                service.markerClusterers[layerName] = new MarkerClusterer(service.map, [],
                    {imagePath: clusterStyle});

                return service.markerClusterers[layerName];
            }
            return null;
        }

        function destroyMapClusterer(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName] = null;
            }
        }

        function createClusterMarker(_position, clusterCount, layerName) {
            if (!service.apiAvailable() || !service.markerClusterers[layerName]) return null;

            var latLngObj = new google.maps.LatLng(_position.lat, _position.lng)
            var cluster = new Cluster(service.markerClusterers[layerName]);

            cluster.center_ = latLngObj;

            cluster.clusterIcon_.setCenter(latLngObj);
            cluster.clusterIcon_.setSums({text: clusterCount, index: Math.round(Math.log(clusterCount) / Math.LN10)});
            cluster.clusterIcon_.textColor_ = 'white';
            cluster.clusterIcon_.show();
            cluster.clusterIcon_.triggerClusterClick = function () {
                var currentZoom = service.map.getZoom();
                service.map.setZoom(++currentZoom);
                service.map.setCenter(cluster.center_);
            };

            return cluster;
        }

        function getClustererInstance(layerName) {
            return service.markerClusterers[layerName];
        }

        function clearClusterMarkers(clusterArray) {
            clusterArray.forEach(function (item, index) {
                if (item instanceof Cluster) {
                    item.remove();
                }
                clusterArray[index] = null;
            });
        }

        function resetClusters(layerName) {
            if (service.markerClusterers[layerName]) {
                service.markerClusterers[layerName].clusters_ = [];
            }
        }

        function insertImageMapType(srcUrl, insertIndex) {
            if (!service.apiAvailable()) return;

            var _insertIndex = insertIndex || 0;

            var imageTile = new google.maps.ImageMapType({
                getTileUrl: function (coord, zoom) {
                    var z2 = Math.pow(2, zoom);
                    var y = coord.y,
                        x = coord.x >= 0 ? coord.x : z2 + coord.x

                    return srcUrl + '/' + zoom + "/" + x + "/" + y + ".png";
                },
                tileSize: new google.maps.Size(256, 256),
                isPng: true,
                opacity: 1.0
            });

            service.map.overlayMapTypes.insertAt(_insertIndex, imageTile);

            return _insertIndex;
        }

        function removeOverlayAtIndex(index) {
            service.map.overlayMapTypes.setAt(index, null);
        }

        function initializeAutocomplete(elementId) {
            var input = document.getElementById(elementId);
            var autocomplete = new google.maps.places.Autocomplete(input, {
                types: ["geocode"]
            });

            autocomplete.bindTo('bounds', service.map);

            return autocomplete;
        }

        function containsLocation (latLng, polygon) {
            if(!polygon) return;

            return google.maps.geometry.poly.containsLocation(latLng, polygon);
        }

        function triggerEvent (obj, event) {
            google.maps.event.trigger(obj, event);
        }

        function highlightPolygon(polygon) {
            if(polygon && polygon.getMap()) {
                polygon.setOptions({
                    fillOpacity: 0.8
                });

                $timeout(function(){
                    polygon.setOptions({
                        fillOpacity: 0
                    });
                }, 1000);
            }
        }

        return service;
    }
}());


(function () {
    'use strict';

    angular.module('demoApp')
        .factory('drawingServices', ['gmapServices', '$rootScope', drawingServices]);

    function drawingServices(gmapServices, $rootScope) {

        var service = {};
        service.drawingManager = null;
        service.drawingCompleteListener = null;

        service.overlay = null;
        service.overlayType = '';
        service.overlayDataArray = [];

        service.strokeColor = '';

        service.duplicateLotPolygon = null;

        service.updateLotPolygon = null;

        /**
         * Functions
         */
        service.initDrawingManager = initDrawingManager;
        service.initDrawingListener = initDrawingListener;
        service.setPanControl = setPanControl;
        service.hideDrawingManager = hideDrawingManager;
        service.startDrawingMode = startDrawingMode;
        service.setListenerOfType = setListenerOfType;
        service.stopDrawingMode = stopDrawingMode;
        service.hideOverlay = hideOverlay;
        service.clearOverlay = clearOverlay;
        service.getAreaCoords = getAreaCoords;
        service.getAreaFormData = getAreaFormData;
        service.getPolygonCoords = getPolygonCoords;
        service.getRectangleCorners = getRectangleCorners;
        service.getRectangleCoords = getRectangleCoords;
        service.duplicateLot = duplicateLot;
        service.destroyDuplicateLot = destroyDuplicateLot;
        service.destroyUpdateLotPolygon = destroyUpdateLotPolygon;


        function initDrawingManager() {
            if (service.drawingManager) {
                if(service.overlayStrokeColor) gmapServices.changeDrawingManagerStrokeColor(service.overlayStrokeColor);

                // Reinitialize Drawing Listener
                service.initDrawingListener();
                return;
            }

            service.drawingManager = gmapServices.createDrawingManager(service.overlayStrokeColor);
            service.initDrawingListener();
        }


        function initDrawingListener() {
            if (!service.drawingManager) return;

            if (service.drawingCompleteListener) return;

            service.drawingCompleteListener = gmapServices.addListener(
                service.drawingManager, 'overlaycomplete', overlayCompleteListener);
        }


        function overlayCompleteListener(eventArgs) {
            // Set only one overlay
            if (service.overlay) {
                service.overlay.setMap(null);
                service.overlay = null;
                service.overlayDataArray = [];
            }

            service.overlay = eventArgs.overlay;
            service.overlay.setMap(gmapServices.map);

            service.overlayType = eventArgs.type;
            service.overlayDataArray = service.getAreaCoords();

            // Add Listener when overlay is resized
            service.setListenerOfType(eventArgs, function (args) {
                service.overlay = args.overlay;
                service.overlayType = args.type;
                service.overlayDataArray = service.getAreaCoords();
            });

            // Set control to pan every after drawing
            service.setPanControl();

            $rootScope.$broadcast('overlay-complete');
        }


        function setPanControl() {
            service.drawingManager.setDrawingMode(null);
        }


        function hideDrawingManager() {
            if (service.drawingManager) {
                gmapServices.hideDrawingManager(service.drawingManager);
            }
        }

        function startDrawingMode(strokeColor) {
            if(strokeColor) service.overlayStrokeColor = strokeColor;

            service.initDrawingManager();

            gmapServices.showDrawingManager(service.drawingManager);
        }

        function setListenerOfType(eArgs, callbackFn) {
            switch (eArgs.type) {
                // Add Listener Events For Rectangle Changed
                case google.maps.drawing.OverlayType.RECTANGLE:
                    google.maps.event.addListener(eArgs.overlay, 'bounds_changed', function () {
                        callbackFn(eArgs);
                    });
                    break;
                // Add Listener Events For Polygon Changed
                case google.maps.drawing.OverlayType.POLYGON:
                    google.maps.event.addListener(eArgs.overlay.getPath(), 'set_at', function () {
                        callbackFn(eArgs);
                    });
                    google.maps.event.addListener(eArgs.overlay.getPath(), 'insert_at', function (e) {
                        callbackFn(eArgs);
                    });
            }
        }

        function stopDrawingMode() {
            if (service.drawingCompleteListener) {
                gmapServices.removeListener(service.drawingCompleteListener);
                service.drawingCompleteListener = null;
            }

            service.hideDrawingManager();

            service.hideOverlay();
        }

        function cancelDrawingMode() {
            service.stopDrawingMode();
        }

        function hideOverlay() {
            if (!service.overlay) return;

            service.overlay.setMap(null);
            service.overlay = null;
        }

        function clearOverlay() {
            hideOverlay();

            service.overlayDataArray = [];
            service.overlayType = '';
        }

        function getAreaCoords() {
            if (service.overlayType == google.maps.drawing.OverlayType.POLYGON) {
                return service.getPolygonCoords();
            }
            else if (service.overlayType == google.maps.drawing.OverlayType.RECTANGLE) {
                return service.getRectangleCorners();
            }

            return [];
        }

        function getPolygonCoords(_polygon) {
            var polygon = _polygon || service.overlay;

            if (!polygon) return;

            var path = polygon.getPath().getArray();
            var data = [];

            for (var index in path) {
                data.push({
                    lat: path[index].lat(),
                    lng: path[index].lng()
                });
            }

            return data;
        }

        function getAreaFormData(_area) {
            return getPolygonCoords(_area);
        }

        function getRectangleCorners(_rect) {
            var rect = _rect || service.overlay;

            if (!rect) return;

            var bounds = rect.getBounds();
            var min = bounds.getNorthEast();
            var max = bounds.getSouthWest();
            var data = [];

            data.push({lat: min.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: max.lng()});
            data.push({lat: min.lat(), lng: max.lng()});

            return data;
        }

        function getRectangleCoords() {
            if (!service.overlay) return;

            var bounds = service.overlay.getBounds();
            var min = bounds.getNorthEast(),
                max = bounds.getSouthWest();
            var data = [];

            data.push({lat: min.lat(), lng: min.lng()});
            data.push({lat: max.lat(), lng: max.lng()});

            return data;
        }

        service.editablePolyOpts = {
            clickable: true,
            draggable: true,
            editable: true,
            geodesic: false,
            fillColor: '#ffffff',
            fillOpacity: 0,
            strokeColor: service.strokeColor,
            strokeOpacity: 0.9,
            strokeWeight: 2,
            zIndex: 99999
        };

        function duplicateLot (lot) {
            if (!lot.polygon) return;
            var path = angular.copy(lot.polygon.getPath());

            if (!service.duplicateLotPolygon)  service.duplicateLotPolygon = gmapServices.createCustomPolygon(path, service.editablePolyOpts);
            else service.duplicateLotPolygon.setPath(path);

            // broadcast here
            $rootScope.$broadcast('duplicate-complete');
        }

        function destroyDuplicateLot () {
            if(!service.duplicateLotPolygon) return;

            service.duplicateLotPolygon.setMap(null);
            service.duplicateLotPolygon = null;
        }

        function destroyUpdateLotPolygon () {
            service.updateLotPolygon = null;
        }

        return service;
    }

}());

(function(){
'use strict';

angular.module('demoApp')
    .factory('crematoriumServices', ['Crematorium', crematoriumServices]);

    function crematoriumServices (Crematorium) {
        var service = {};



        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('columbaryServices', ['$q', 'Columbary', columbaryServices]);

    function columbaryServices ($q, Columbary) {
        var service = {};

        service.columbaryList = [];
        service.columbaryData = null;

        service.getDataWithParams = getDataWithParams;
        service.getData = getData;

        service.getAllData = getAllData;
        service.filterByBlock = filterByBlock;
        service.filterByStatus = filterByStatus;

        function getDataWithParams (params) {
            var dfd = $q.defer();

            Columbary.get('', params)
                .then(function (response) {
                    // reset columbary data
                    service.columbaryData = null;

                    if (response.columbary) service.columbaryData = angular.copy(response);
                    dfd.resolve(service.columbaryData);

                }, function (error) {
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function getData (pageNo, block) {
            var params = {};

            params['page'] = pageNo || 1;
            if (block) params['block'] = block;

            return service.getDataWithParams(params);
        }

        function getAllData() {
            var dfd = $q.defer();

            Columbary.all('all').getList()
                .then(function(response){
                    // reset list
                    service.columbaryList = [];

                    response.forEach(function(item){
                        service.columbaryList.push(Columbary.cast(item));
                    });

                    dfd.resolve(service.columbaryList);

                }, function(error) {
                    dfd.reject(error);
                });

            return dfd.promise;
        }

        function filterByBlock (_block) {
            return _.where(service.columbaryList, {block: _block || 'A'});
        }

        function filterByStatus (status, block) {
            return status
                    ? _.where(service.columbaryList, {status: status})
                    : filterByBlock(block);
        }

        return service;
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .factory('blockList', ['lotList', 'gmapServices', blockList]);

    function blockList (lotList, gmapServices) {
        var service = {};

        service.polygoncolor = '#ffffff';
        service.polygonOptions = {
            clickable: true,
            fillColor: service.polygoncolor,
            fillOpacity: 0,
            strokeColor: service.polygoncolor,
            strokeOpacity: 0.3,
            strokeWeight: 2,
            zIndex: 100
        };

        service.blocks = {};

        service.loadBlocksForSection = loadBlocksForSection;
        service.add = add;

        function loadBlocksForSection (section, forIndex) {
            if(!section.blocks) return;

            section.blocks.forEach(function(block){
                service.add(section.id, block, forIndex);
            });
        }

        function add (sectionId, data, forIndex) {
            if (!service.blocks[sectionId]) service.blocks[sectionId] = [];

            // #Note: Remove Polygon for blocks
            // instead lower the opacity #done
            data.polygon = createPolygon(data, forIndex);

            lotList.loadLotsForBlock(data, forIndex);

            service.blocks[sectionId].push(data);
        }

        function createPolygon(block, forIndex) {
            var polygon = gmapServices.createCustomPolygon(block.area, service.polygonOptions);

            var adminHandler = function () {
                console.log('admin handler for polygon click block');
            };

            var indexHandler = function () {
                console.log('index handler for polygon click block');
                //$mdSidenav('blockDetailsIndexSidenav')
                //    .open()
                //    .then(function () {
                //        $rootScope.$broadcast('show-block-details', {block: block});
                //    });
            };

            var handler = forIndex ? indexHandler : adminHandler;

            gmapServices.addListener(polygon, 'click', function() {
                gmapServices.setZoomIfGreater(21);
                gmapServices.panToPolygon(polygon);
                //handler();
                gmapServices.highlightPolygon(polygon);
                console.log('block polygon cliked');
            });

            return polygon;
        }

        return service;
    }
}());
(function () {
'use strict';

angular.module('demoApp')
    .factory('alertServices', ['$mdToast', 'SweetAlert', alertServices]);

    function alertServices($mdToast, SweetAlert) {
        var service = {};

        service.showTopRightToast = showTopRightToast;
        service.showMessage = showMessage;
        service.showPrompt = showPrompt;
        service.showLotAdded = showLotAdded;
        service.settingsSuccessfullySaved = settingsSuccessfullySaved;
        service.showErrorMessage = showErrorMessage;

        function showToast(message, position) {
            $mdToast.show(
                $mdToast.simple()
                    .textContent(message)
                    .position(position)
                    .hideDelay(2000)
            );
        }

        function showTopRightToast(message) {
            showToast(message, 'top right');
        }

        function showMessage(message, type) {
            SweetAlert.swal({
                title: message,
                type: type
            });
        }

        function showLotAdded () {
            service.showTopRightToast('Lot Added.');
        }

        function settingsSuccessfullySaved () {
            showMessage('Settings Updated!', 'success');
        }

        function showErrorMessage (error) {
            showMessage(error, 'error');
        }

        function showPrompt(entity, callback) {
            SweetAlert.swal({
                title: "Are you sure?",
                text: "Deleting " + entity,
                type: "warning",
                showCancelButton: true,
                confirmButtonColor: "#DD6B55", confirmButtonText: "Yes, delete it!",
                cancelButtonText: "Cancel",
                closeOnConfirm: false,
                closeOnCancel: false
            }, callback);
        }

        return service;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Settings', ['Restangular', Settings]);

    function Settings(Restangular) {
        var resourceModel = Restangular.all('settings');

        Restangular.extendModel('settings', function (model) {

            model.getLastLotPrice = function () {
                return model
                    .customGET('lastLot_price');
            };

            return model;
        });


        return resourceModel;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Sections', ['Restangular', Sections]);

    function Sections(Restangular) {
        var resourceModel = Restangular.all('sections');

        Restangular.extendModel('sections', function (model) {

            model.addBlock = function (block) {
                return model
                    .all('blocks')
                    .customPOST(block);
            };

            return model;
        });

        return resourceModel;
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Lots', ['Restangular', Lots]);

    function Lots(Restangular) {
        var model = Restangular.all('lots');

        Restangular.extendModel('lots', function (model) {

            model.updateDimension = function (dimension) {
                //console.log('update lot dimension: ', dimension);

                return model
                    .all('dimension')
                    .customPUT(dimension);
            };

            model.updatePrice = function (newPrice) {
                console.log('update lot price: ', newPrice);

                return model
                    .all('price')
                    .customPUT(newPrice);
            };

            model.updateORNo = function (ORNo) {
                console.log('update lot or no: ', ORNo);

                return model
                    .all('or_no')
                    .customPUT(ORNo);
            };

            model.updateRemarks = function (data) {
                console.log('update remarks: ', data);

                return model
                    .all('remarks')
                    .customPUT(data);
            };

            model.updateName = function (data) {
                console.log('update name: ', data);

                return model
                    .all('name')
                    .customPUT(data);
            };

            model.updateLotArea = function (data) {
                console.log('update lot area: ', data);

                return model
                    .all('lot_area')
                    .customPUT(data);
            };

            return model;
        });

        return angular.extend(model, {
            cast: function(lot) {
              if(lot.polygon) lot.polygon = null;
              return Restangular.restangularizeElement(null, lot, 'lots');
            }
        });
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Deceased', ['Restangular', Deceased]);

    function Deceased(Restangular) {
        var model = Restangular.all('deceased');

        return angular.extend(model, {
            cast: function(deceased) {
              return Restangular.restangularizeElement(null, deceased, 'deceased');
            }
        });
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Crematorium', ['Restangular', Crematorium]);

    function Crematorium(Restangular) {
        var model = Restangular.all('crematorium');

        return angular.extend(model, {
            cast: function (c) {
                return Restangular.restangularizeElement(null, c, 'crematorium');
            }
        });
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Columbary', ['Restangular', Columbary]);

    function Columbary(Restangular) {
        var model = Restangular.all('columbary');

        return angular.extend(model, {
            cast: function (c) {
                return Restangular.restangularizeElement(null, c, 'columbary');
            }
        });
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Clients', ['Restangular', Clients]);

    function Clients(Restangular) {
        var model = Restangular.all('clients');

        return angular.extend(model, {
            cast: function(client) {
              return Restangular.restangularizeElement(null, client, 'clients');
            }
        });
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .factory('Blocks', ['Restangular', Blocks]);

    function Blocks(Restangular) {
        var model = Restangular.all('blocks');

        return angular.extend(model, {
            cast: function(block) {
              block.polygon = null;
              return Restangular.restangularizeElement(null, block, 'blocks');
            }
        });
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .directive('allowPattern', [allowPatternDirective]);

    // TODO modify this to allow only digit then "x" alternative
    // ex: 55x6x6x - allowed
    //     555xxx55xxx - not allowed
    function allowPatternDirective() {
        return {
            restrict: "A",
            compile: function (tElement, tAttrs) {
                return function (scope, element, attrs) {
                    // I handle key events
                    element.bind("keypress", function (event) {
                        var keyCode = event.which || event.keyCode; // I safely get the keyCode pressed from the event.
                        var keyCodeChar = String.fromCharCode(keyCode); // I determine the char from the keyCode.

                        // If the keyCode char does not match the allowed Regex Pattern, then don't allow the input into the field.
                        if (!keyCodeChar.match(new RegExp(attrs.allowPattern, "i"))) {
                            event.preventDefault();
                            return false;
                        }

                    });
                };
            }
        };
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('updateDeceasedController', ['deceased', '$rootScope', '$scope', 'modalServices', updateDeceasedController]);

    function updateDeceasedController(deceased, $rootScope, $scope, modalServices) {
        var vm = this;

        vm.deceased = {};

        vm.save = save;
        vm.cancel = cancel;
        vm.clearForm = clearForm;


        $scope.maxDate = new Date();

        /* Controller Functions here */

        function initialize() {
            vm.deceased = deceased;
            console.log('deceased: ', deceased);
        }

        function save() {
            vm.deceased.put()
                .then(function (response) {
                    console.log('Update Deceased: ', response);
                    //$mdDialog.hide();
                }, function (err) {
                    console.log('Error Updating deceased: ', err);
                });
        }

        function cancel() {
            modalServices.closeModal();
        }

        function clearForm() {
            vm.deceased = {};
            $scope.updateDeceasedForm.$setPristine();
        }

        initialize();

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('settingsController', ['$mdDialog', 'Settings', 'alertServices', 'lastLot', settingsController]);

    function settingsController ($mdDialog, Settings, alertServices, lastLot) {
        var vm = this;

        vm.settings = {
            price_per_sq_mtr: ''
        };

        vm.lastLotPrice = {};

        vm.initialize = initialize;
        vm.save = save;
        vm.cancel = cancel;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            vm.lastLotPrice = lastLot;
            console.log('lastLotPrice: ',vm.lastLotPrice);
        }

        function save () {
            Settings.post(vm.settings)
                .then(function (response) {
                    console.log('Success saving settings: ',response);
                    alertServices.settingsSuccessfullySaved();
                    $mdDialog.hide(response);
                }, function (error) {
                    console.log('Error: ', error);
                    // Show Errors
                });
        }

        function cancel () {
            $mdDialog.cancel();
        }

        /* Non Scope Functions here */

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('sectionDetailsIndexController', ['$rootScope', '$mdSidenav', 'sectionList', 'blockList', 'lotList', 'gmapServices', 'drawingServices', 'modalServices', sectionDetailsIndexController]);

    function sectionDetailsIndexController ($rootScope, $mdSidenav, sectionList, blockList, lotList, gmapServices, drawingServices, modalServices) {
        var vm = this;

        vm.lastPolygon = null;

        vm.editMode = false;
        vm.tempSection = {
            name: null,
            polygon: null,
            area: []
        };

        var saveListener = {
            block: null,
            lot: null
        };

        vm.section = {
          id: '',
          name: '',
          blocks: [],
          area: []
        };

        vm.sectionInfo = {
            lotCount: 0,
            soldLot: 0,
            unsoldLot: 0
        };


        vm.initialize = initialize;
        vm.close = close;

        vm.editSection = editSection;
        vm.saveChanges = saveChanges;

        vm.addBlock = addBlock;
        vm.showBlock = showBlock;

        vm.addLot = addLot;
        vm.onLotClick = onLotClick;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            $rootScope.$on('show-section-details', function(event, params){
                vm.editMode = false;
                vm.section = params.section;

                vm.tempSection.name = params.section.name;

                updateSectionDetails(vm.section);

                var tempSectionPolygon = angular.copy(vm.section.polygon);
                //var tempSectionPolygon = vm.section.polygon;

                gmapServices.hidePolygon(vm.section.polygon);

                if(vm.lastPolygon) {
                    gmapServices.setEditablePolygon(vm.lastPolygon, false);
                    gmapServices.showPolygon(vm.lastPolygon)
                }

                vm.lastPolygon = vm.section.polygon;

                if(vm.tempSection.polygon) {
                    gmapServices.hidePolygon(vm.tempSection.polygon);
                    vm.tempSection.polygon = null;
                }

                vm.tempSection.polygon = tempSectionPolygon;
                //vm.tempSection.polygon = gmapServices.createCustomPolygon(vm.section.area, sectionList.polygonOptions);
            });
        }

        function resetSectionInfo() {
            for (var key in vm.sectionInfo) {
                vm.sectionInfo[key] = 0;
            }
        }

        function updateSectionDetails (section) {
            console.log('section details: ',section);

            resetSectionInfo();

            section.blocks.forEach(function(blk){
                vm.sectionInfo.lotCount += blk.lots.length;
                vm.sectionInfo.soldLot += _.where(blk.lots, {status: 'sold'}).length;
                vm.sectionInfo.soldLot += _.where(blk.lots, {status: 'occupied'}).length;
                vm.sectionInfo.unsoldLot += _.where(blk.lots, {status: 'vacant'}).length;
            });
        }

        /* Section Functions */

        function editSection () {
            toggle(true);
        }

        function saveChanges () {
            toggle(false);
            vm.tempSection.area = drawingServices.getPolygonCoords(vm.tempSection.polygon);

            // to avoid this error "TypeError: Converting circular structure to JSON"
            vm.section.polygon = null;

            vm.section.area = vm.tempSection.area;
            vm.section.name = vm.tempSection.name;

            vm.section.customPUT({area: vm.tempSection.area, name: vm.tempSection.name})
                .then(function(response){
                    gmapServices.hidePolygon(vm.tempSection.polygon);
                    vm.tempSection.polygon = null;
                    vm.lastPolygon = null;

                    vm.section.polygon = gmapServices.createCustomPolygon(vm.section.area, sectionList.polygonOptions);

                }, function(error){
                    console.log('failed updating section: ',error);
                });
        }

        /* End Section Functions */


        /* Block Functions */

        function addBlock(ev) {
            $rootScope.$broadcast('start-drawing');
            drawingServices.startDrawingMode('#e74c3c');

            saveListener.block = $rootScope.$on('save-area', function (event, param) {
                modalServices.showAddBlock(ev, vm.section, param.area)
                    .then(function (result) {
                        blockList.add(result.block.section_id, result.block);
                        vm.section.blocks.push(result.block);
                    }, function (reason) {
                        console.log('failed: ', reason);
                    })
                    .finally(function(){
                        // destroy listener
                        saveListener.block();
                        saveListener.block = null;
                    });
            });
        }

        function showBlock(block) {
            gmapServices.setZoomIfGreater(21);
            gmapServices.panToPolygon(block.polygon);
            gmapServices.highlightPolygon(block.polygon);
        }

        /* End of Block Functions */

        /* Lot Functions */

        function addLot(ev, block) {
            $rootScope.$broadcast('start-drawing');
            drawingServices.startDrawingMode('#2ecc71');

            console.log('Block: ',block);

            saveListener.lot = $rootScope.$on('save-area', function (event, param) {
                modalServices.showAddLot(ev, block, param.area)
                    .then(function (result) {
                        lotList.add(block, result.lot);
                        block.lots.push(result.lot);
                    }, function (reason) {
                        console.log('failed: ', reason);
                    })
                    .finally(function () {
                        // destroy listener
                        saveListener.lot();
                        saveListener.lot = null;
                    });
            });
        }

        function onLotClick (lot) {
            var foundLot = lotList.findLot(lot.block_id, lot.id);
            if (foundLot) gmapServices.triggerEvent(foundLot.polygon, 'click');
        }

        /* End of Lot Functions */


        function toggle(flag) {
            vm.editMode = flag;
            gmapServices.setEditablePolygon(vm.tempSection.polygon, flag);
        }

        vm.openBlockMenu = openBlockMenu;
        var originatorEv;

        function openBlockMenu($mdOpenMenu, ev) {
            originatorEv = ev;
            $mdOpenMenu(ev);
        };

        function close () {
            $mdSidenav('sectionDetailsIndexSidenav')
                .close()
                //.then(function(){
                //    vm.section = {
                //        id: '',
                //        name: '',
                //        area: []
                //    };
                //})
            ;
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('sectionDetailsController', ['$rootScope', '$mdSidenav', 'sectionList', 'blockList', 'lotList', 'gmapServices', 'drawingServices', 'modalServices', sectionDetailsController]);

    function sectionDetailsController ($rootScope, $mdSidenav, sectionList, blockList, lotList, gmapServices, drawingServices, modalServices) {
        var vm = this;

        vm.lastPolygon = null;

        vm.editMode = false;
        vm.tempSection = {
            name: null,
            polygon: null,
            area: []
        };

        var saveListener = {
            block: null,
            lot: null
        };

        vm.section = {
          id: '',
          name: '',
          blocks: [],
          area: []
        };


        vm.initialize = initialize;
        vm.close = close;

        vm.editSection = editSection;
        vm.saveChanges = saveChanges;

        vm.addBlock = addBlock;
        vm.showBlock = showBlock;

        vm.addLot = addLot;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            $rootScope.$on('show-section-details', function(event, params){
                console.log('show-section-details');

                vm.editMode = false;
                vm.section = params.section;
                vm.tempSection.name = params.section.name;

                var tempSectionPolygon = angular.copy(vm.section.polygon);

                gmapServices.hidePolygon(vm.section.polygon);

                if(vm.lastPolygon) {
                    gmapServices.setEditablePolygon(vm.lastPolygon, false);
                    gmapServices.showPolygon(vm.lastPolygon)
                }

                vm.lastPolygon = vm.section.polygon;

                if(vm.tempSection.polygon) {
                    gmapServices.hidePolygon(vm.tempSection.polygon);
                    vm.tempSection.polygon = null;
                }

                vm.tempSection.polygon = tempSectionPolygon;
                console.log('vm.tempSection.polygon: ', vm.tempSection.polygon);
                //vm.tempSection.polygon = gmapServices.createCustomPolygon(vm.section.area, sectionList.polygonOptions);
            });
        }

        /* Section Functions */

        function editSection () {
            toggle(true);
        }

        function saveChanges () {
            toggle(false);
            vm.tempSection.area = drawingServices.getPolygonCoords(vm.section.polygon);
            //vm.tempSection.area = drawingServices.getPolygonCoords(vm.tempSection.polygon);


            console.log('vm.section: ', vm.section);
            // to avoid this error "TypeError: Converting circular structure to JSON"
            vm.section.polygon = null;
            var tempBlocks = vm.section.blocks;
            vm.section.blocks = [];

            vm.section.area = vm.tempSection.area;
            vm.section.name = vm.tempSection.name;

            vm.section.put()
                .then(function(response){
                    //gmapServices.hidePolygon(vm.tempSection.polygon);
                    //vm.tempSection.polygon = null;
                    //vm.lastPolygon = null;
                    gmapServices.hidePolygon(vm.section.polygon);
                    vm.section.polygon = null;
                    vm.lastPolygon = null;

                    vm.section.polygon = gmapServices.createCustomPolygon(vm.section.area, sectionList.polygonOptions);
                }, function(error){
                    console.log('failed updating section: ',error);
                    vm.section.polygon = vm.tempSection.polygon;
                })
                .finally(function(){
                    vm.section.blocks = tempBlocks;
                });
        }

        /* End Section Functions */


        /* Block Functions */

        function addBlock(ev) {
            $rootScope.$broadcast('start-drawing');
            drawingServices.startDrawingMode('#e74c3c');

            saveListener.block = $rootScope.$on('save-area', function (event, param) {
                modalServices.showAddBlock(ev, vm.section, param.area)
                    .then(function (result) {
                        blockList.add(result.block.section_id, result.block);
                        vm.section.blocks.push(result.block);
                    }, function (reason) {
                        console.log('failed: ', reason);
                    })
                    .finally(function(){
                        // destroy listener
                        saveListener.block();
                        saveListener.block = null;
                    });
            });
        }

        function showBlock(block) {
            gmapServices.setZoomIfGreater(21);
            gmapServices.panToPolygon(block.polygon);
            gmapServices.highlightPolygon(block.polygon);
        }

        /* End of Block Functions */

        /* Lot Functions */

        function addLot(ev, block) {
            $rootScope.$broadcast('start-drawing');
            drawingServices.startDrawingMode('#2ecc71');

            saveListener.lot = $rootScope.$on('save-area', function (event, param) {
                modalServices.showAddLot(ev, block, param.area)
                    .then(function (result) {
                        lotList.add(block, result.lot);
                        block.lots.push(result.lot);
                    }, function (reason) {
                        console.log('failed: ', reason);
                    })
                    .finally(function () {
                        // destroy listener
                        saveListener.lot();
                        saveListener.lot = null;
                    });
            });
        }

        /* End of Lot Functions */


        function toggle(flag) {
            vm.editMode = flag;
            gmapServices.setEditablePolygon(vm.section.polygon, flag);
            //gmapServices.setEditablePolygon(vm.tempSection.polygon, flag);
        }

        vm.openBlockMenu = openBlockMenu;
        var originatorEv;

        function openBlockMenu($mdOpenMenu, ev) {
            originatorEv = ev;
            $mdOpenMenu(ev);
        };

        function close () {
            $mdSidenav('sectionDetailsSidenav')
                .close()
                //.then(function(){
                //    vm.section = {
                //        id: '',
                //        name: '',
                //        area: []
                //    };
                //})
            ;
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('salesReportController', ['$scope', '$mdDialog', 'BASE_URL', salesReportController]);

    function salesReportController ($scope, $mdDialog, BASE_URL) {
        var vm = this;

        vm.maxDate = new Date();

        vm.reportDate = {
          start: null,
          end: null
        };

        vm.reportDateData = {
            start: null,
            end: null
        };

        vm.initialize = initialize;
        vm.generateReport = generateReport;
        vm.cancel = cancel;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            $scope.$watch(function(){
               return vm.reportDate.start;
            }, function(newValue, oldValue){
                if(newValue === oldValue) return;
                vm.reportDateData.start = parseDate(vm.reportDate.start);
            });

            $scope.$watch(function () {
                return vm.reportDate.end;
            }, function (newValue, oldValue) {
                if (newValue === oldValue) return;
                vm.reportDateData.end = parseDate(vm.reportDate.end);
            });
        }

        function parseDate(date) {
            return date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate();
        }

        function getDatesForUrl () {
            return '?start='+vm.reportDateData.start+'&end='+vm.reportDateData.end;
        }

        function generateReport () {
            var datesUrl = getDatesForUrl();
            window.open(BASE_URL + '/reports/sales' + datesUrl);
            $mdDialog.hide();
        }

        function cancel () {
            $mdDialog.cancel();
        }

        /* Non Scope Functions here */

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('newCremationController', ['$scope', '$rootScope', 'Crematorium', 'modalServices', newCremationController]);

    function newCremationController ($scope, $rootScope, Crematorium, modalServices) {
        var vm = this;

        vm.currentDate = new Date();

        vm.cremation = {
            deceased: {
                first_name: '',
                last_name: '',
                middle_name: '',
                gender: '',
                date_of_birth: '',
                date_of_death: '',
            },
            date_cremated: '',
            time_started: '',
            time_finished: '',
            gas_consumed: ''
        };

        vm.cremationClear = angular.copy(vm.cremation);

        vm.cremationDates = {
            date_of_birth: '',
            date_of_death: '',
            time_started: '',
            time_finished: '',
        };

        vm.cremationDatesClear = angular.copy(vm.cremationDates);

        vm.initialize = initialize;
        vm.save = save;
        vm.close = close;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            $scope.$watch(function () {
                return vm.cremationDates.date_cremated;
            }, function (newDate, oldDate) {
                if (!newDate || newDate === oldDate) return;
                vm.cremation.date_cremated = newDate.getFullYear() + '-' +
                    (newDate.getMonth() + 1) + '-' +
                    newDate.getDate();
            });

            $scope.$watch(function () {
                return vm.cremationDates.date_of_birth;
            }, function (newDate, oldDate) {
                if (!newDate || newDate === oldDate) return;
                vm.cremation.deceased.date_of_birth = newDate.getFullYear() + '-' +
                                            (newDate.getMonth()+1) + '-' +
                                            newDate.getDate();
            });

            $scope.$watch(function () {
                return vm.cremationDates.date_of_death;
            }, function (newDate, oldDate) {
                if (!newDate || newDate === oldDate) return;
                vm.cremation.deceased.date_of_death = newDate.getFullYear() + '-' +
                    (newDate.getMonth() + 1) + '-' +
                    newDate.getDate();
            });

            $scope.$watch(function(){
                return vm.cremationDates.time_started;
            }, function(newDate, oldDate) {
               if(!newDate || newDate === oldDate) return;
               vm.cremation.time_started = newDate.getHours() + ':' + newDate.getMinutes();
            });

            $scope.$watch(function () {
                return vm.cremationDates.time_finished;
            }, function (newDate, oldDate) {
                if (!newDate || newDate === oldDate) return;
                vm.cremation.time_finished = newDate.getHours() + ':' + newDate.getMinutes();
            });

            $rootScope.$watch('showNewCremationFormPanel', function(newValue, oldValue){
                //console.log('scope destroyed');
                if(newValue === oldValue) return;
                if(!newValue) modalServices.showCrematorium(null);
            });
        }

        function save () {
            console.log('save new cremation: ', vm.cremation);
            Crematorium.customPOST(vm.cremation)
                .then(function(response){
                   console.log('saved cremation: ', response.cremation);
                    $rootScope.cremations.push(response.cremation);
                    close();
                },function(error){
                    console.log('error saving cremation: ', error);
                }).finally( function(){
                    vm.cremation = angular.copy(vm.cremationClear);
                    vm.cremationDates = angular.copy(vm.cremationDatesClear);
                    $scope.newCremationForm.$setPristine();
                });
        }

        function close () {
            $rootScope.showNewCremationFormPanel = false;
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('mainController', ['$scope', '$rootScope', 'BASE_URL', 'modalServices', mainController]);

    function mainController ($scope, $rootScope, BASE_URL, modalServices) {
        var vm = this;

        $rootScope.spinner = {
            active: false
        };

        $rootScope.currentUser = {
          username: 'User1',
          role: 'USER'
        };

        vm.menu = [
            {
                link: '/admin',
                title: 'Admin',
                icon: 'group'
            },
            {
                title: 'Settings',
                icon: 'settings'
            },
            {
                link: '/logout',
                title: 'Logout',
                icon: 'exit_to_app'
            }
        ];

        vm.isFabOpen = false;
        vm.tooltipVisible = false;

        vm.initialize = initialize;
        vm.redirect = redirect;
        vm.openSettings = openSettings;

        vm.generateLotListReport = generateLotListReport;
        vm.generateSalesReport = generateSalesReport;
        vm.generateCremationListReport = generateCremationListReport;

        vm.initialize();

        function initialize () {
            // TODO: fetch logged in user data
            // and add in local storage

            $scope.$watch(function(){
                return vm.isFabOpen;
            }, function(newValue, oldValue){
                if(newValue === oldValue) return;
                vm.tooltipVisible = vm.isFabOpen;
            });
        //    sectionList.loadSections(); // Transferred to Admin Controller
        }

        function redirect(e, link) {
            e.preventDefault();

            if(link == '/admin'  || link == '/logout') {
                console.log('link: ', link);
                window.location = BASE_URL + link;
                return;
            }

            vm.openSettings(e);
        }

        function openSettings (e) {
            modalServices.showSettings(e);
        }

        function generateLotListReport () {
            window.open(BASE_URL + '/reports/lot_list');
        }

        function generateSalesReport () {
            modalServices.showSalesReport();
        }

        function generateCremationListReport () {
            modalServices.showCremationListReport();
        }

    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('lotListController', ['$rootScope', '$scope', 'sectionList', 'lotList', 'gmapServices', '$timeout', 'LOT_STATUSES_JSON', 'modalServices', lotListController]);

    function lotListController($rootScope, $scope, sectionList, lotList, gmapServices, $timeout, LOT_STATUSES_JSON, modalServices) {
        var vm = this;

        vm.showList = false;

        $rootScope.showNewCremationFormPanel = false;

        // complete list of Solars from the server
        $rootScope.lotList = [];

        $rootScope.lotsDetail = {
            count: {
                all: 0,
                sold: 0,
                vacant: 0,
                occupied: 0
            }
        };

        vm.query = {
            order: 'status',
            limit: 10,
            page: 1,
            filter: ''
        };

        vm.filter = {
            show: false,
            form: null
        };

        vm.searchFilters = {
            section_id: "",
            block_id: "",
            id: "",
            lot_area: "",
            price_per_sq_mtr: "",
            amount: "",
            status: "",
            client_name: "",
            date_purchased_formatted: ""
        };

        vm.searchInfowindow = gmapServices.createInfoWindow('');

        // Table Header
        vm.tableHeaderList = [
            'Section',
            'Block',
            'Lot No.',
            'Dimension',
            'Area',
            'Amount (Price/SM)',
            'Status',
            'OR #',
            'Owner',
            'Date Purchased',
            'Action'
        ];

        vm.initialize = initialize;
        vm.toggleList = toggleList;
        vm.close = close;
        vm.onClickRow = onClickRow;
        vm.showLotDetails = showLotDetails;
        vm.onReorder = onReorder;
        vm.removeFilter = removeFilter;

        vm.initialize();

        function initialize() {
            sectionList.loadSections(true);

            loadLots();

            $(document).on('click', '.show-lot-detail-button', function () {
                var lotId = $(this).data('lot-id'),
                    blockId = $(this).data('block-id');

                var foundLot = lotList.findLot(blockId, lotId);

                if(foundLot) {
                    vm.searchInfowindow.close();
                    gmapServices.triggerEvent(foundLot.polygon, 'click');
                }
            });

            $scope.$watch(angular.bind(vm, function () {
                return vm.query.filter;
            }), startFilter);

            $rootScope.$watchCollection('lotList', updateLotsDetail);

            $rootScope.$on('toggle-lot-polygons',function (event, params) {
                var status = params.status,
                    value = params.value
                ;

                lotList.togglePolygonByStatus(status, value);
            });
        }

        function toggleList() {
            vm.showList = !vm.showList;
        }

        function updateLotsDetail (newList) {
            $rootScope.lotsDetail.count.all = newList.length;
            $rootScope.lotsDetail.count.vacant = _.where(newList, {status: LOT_STATUSES_JSON.VACANT}).length;
            $rootScope.lotsDetail.count.sold = _.where(newList, {status: LOT_STATUSES_JSON.SOLD}).length;
            $rootScope.lotsDetail.count.occupied = _.where(newList, {status: LOT_STATUSES_JSON.OCCUPIED}).length;
        }

        /* Table Functions */

        function onReorder() {}

        function removeFilter() {
            vm.filter.show = false;
            vm.query.filter = '';

            if (vm.filter.form.$dirty) {
                vm.filter.form.$setPristine();
            }
        }

        function onClickRow(lot) {
            gmapServices.triggerEvent(lot.polygon, 'click');
        }

        function showLotDetails (lot) {
            var foundLot = lotList.findLot(lot.block_id, lot.id);

            if (foundLot) {
                $timeout(function(){
                    vm.searchInfowindow.close();
                }, 300);
                lotList.showLotDetailsModal(foundLot);
            }
        }

        function loadLots() {
            $rootScope.lotList = lotList.lots;
            filterList();

            console.log('lots: ',$rootScope.lots);
        }

        function startFilter() {
            vm.query.filter = vm.query.filter.toLowerCase();

            for (var key in vm.searchFilters) {
                if (vm.searchFilters.hasOwnProperty(key)) {
                    vm.searchFilters[key] = vm.query.filter;
                }
            }

            filterList();
        }

        function filterList() {
            if (isEmptyFilter()) {
                $rootScope.lots = lotList.lots;
            } else {
                var filtered = manualFilter(vm.searchFilters);
                $rootScope.lots = filtered;
            }
        }

        function manualFilter (searchFilters) {
            var result = [];
            $rootScope.lotList.forEach(function(lot){
                for (var key in searchFilters) {
                    var lotData = String(lot[key]).toLowerCase();
                    if(lotData.indexOf(vm.query.filter) !== -1) {
                        result.push(lot);
                        return;
                    }
                }
            });
            return result;
        }

        function isEmptyFilter() {
            return vm.query.filter === '';
        }

        function close() {
            $mdDialog.hide();
        }


        /* Columbary Functions */

        vm.showColumbaryModal = showColumbaryModal;

        function showColumbaryModal (e) {
            modalServices.showColumbaryList(e);
        }

        /* Crematorium functions */

        vm.showCrematorium = showCrematorium;

        function showCrematorium(e) {
            modalServices.showCrematorium(e);
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('lotDetailsController', ['$scope', '$mdDialog', 'lot', 'modalServices', '$q', 'lotHelper', 'Restangular', 'alertServices', 'Deceased', lotDetailsController]);

    function lotDetailsController ($scope, $mdDialog, lot, modalServices, $q, lotHelper, Restangular, alertServices, Deceased) {
        var vm = this;

        $scope.showEditLotNameForm = false;
        $scope.showEditLotORNoForm = false;
        $scope.showEditLotDimensionForm = false;
        $scope.showEditLotPriceForm = false;
        $scope.showEditLotRemarksForm = false;
        $scope.showEditLotAreaForm = false;
        $scope.showEditLotBlockNoForm = false;

        vm.lot = null;
        vm.blocks = [];

        vm.initialize = initialize;
        vm.markSold = markSold;
        vm.addOccupant = addOccupant;

        vm.updateLot = updateLot;

        vm.updateLotORNo = updateLotORNo;
        vm.updateLotDimension = updateLotDimension;
        vm.updateLotPrice = updateLotPrice;
        vm.updateLotRemarks = updateLotRemarks;
        vm.updateLotName = updateLotName;
        vm.updateLotArea = updateLotArea;
        vm.updateLotBlockNo = updateLotBlockNo;

        vm.showUpdateDeceased = showUpdateDeceased;
        vm.deleteDeceased = deleteDeceased;

        vm.cancel = cancel;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            vm.lot = lot;
            console.log('lot details: ', vm.lot);

            //vm.lot_copy = angular.copy(vm.lot);

            //$scope.$watch(function(){
            //    return vm.lot;
            //}, function(newValue){
            //    vm.lot_copy = angular.copy(newValue);
            //});

            $scope.$watch(function () {
                return vm.lot.lot_area;
            }, computeLotAmount);

            $scope.$watch(function () {
                return vm.lot.price_per_sq_mtr;
            }, computeLotAmount);

            $scope.$watch(function () {
                return vm.lot.dimension;
            }, function (newValue, oldValue) {
                if (newValue == oldValue) return;
                computeLotArea(newValue);
            });

            Restangular
                .one('sections', vm.lot.block.section_id)
                .all('blocks')
                .getList()
                .then(function(response){
                   console.log('get all blocks for section '+vm.lot.block.section.name, response);
                    response.forEach(function(block){
                       vm.blocks.push(block);
                    });
                },function(error){
                    console.log('error getting all blocks for section', error);
                });
        }

        function computeLotArea(dimension) {
            var result = lotHelper.computeArea(dimension);

            vm.lot.dimension = result.dimension;
            vm.lot.lot_area = result.area;
        }

        function markSold () {
            // TODO show modal to select or add new client and a datepicker to select date sold
            // add functionality to update database
            console.log('mark sold lot');

            modalServices.showClientSelection(vm.lot)
                .then(function(success){
                    console.log('ShowClientSelection: ',success);
                    vm.lot.status = 'sold';
                },function(err){
                    console.log('ShowClientSelection: ', err);
                });
        }

        function addOccupant () {
            console.log('add occupant');
            // add functionality to update database
            modalServices.showAddOccupant(vm.lot)
                .then(function (success) {
                    console.log('Show Add Occupant: ', success);
                }, function (err) {
                    console.log('Show Add Occupant: ', err);
                });
        }

        function updateLot () {
            var dfd = $q.defer();
            vm.lot.put()
                .then(function (response) {
                    dfd.resolve(response);
                }, function (error) {
                    dfd.reject(error);
                });
            return dfd.promise;
        }

        function updateLotPrice () {
            updateLot()
                .then(function (response) {
                    vm.lot.price_per_sq_mtr = response.lot.price_per_sq_mtr;
                    $scope.showEditLotPriceForm = false;
                });
        }

        function updateLotORNo () {
            updateLot()
                .then(function (response) {
                    vm.lot.or_no = response.lot.or_no;
                    $scope.showEditLotORNoForm = false;
                });
        }

        function updateLotDimension () {
            updateLot()
                .then(function (response) {
                    vm.lot.lot_area = response.lot.lot_area;
                    vm.lot.dimension = response.lot.dimension;
                    $scope.showEditLotDimensionForm = false;
                });
        }

        function updateLotRemarks () {
            updateLot()
                .then(function (response) {
                    vm.lot.remarks = response.lot.remarks;
                    $scope.showEditLotRemarksForm = false;
                });
        }

        function updateLotName () {
            updateLot()
                .then(function(response){
                    vm.lot.name = response.lot.name;
                    $scope.showEditLotNameForm = false;
                });
        }


        function updateLotArea() {
            updateLot()
                .then(function (response) {
                    vm.lot.lot_area = response.lot.lot_area;
                    $scope.showEditLotAreaForm = false;
                });
        }

        function updateLotBlockNo () {
            updateLot()
                .then(function (response) {
                    vm.lot.block_id = response.lot.block_id;
                    vm.lot.block = response.lot.block;
                    $scope.showEditLotBlockNoForm = false;
                });
        }

        function showUpdateDeceased (deceased) {
            // show modal
            modalServices.showUpdateDeceased(Deceased.cast(deceased))
                .then(function (response) {
                });
        }

        function deleteDeceased (deceased) {
            var callback = function (isConfirm) {
              if (isConfirm) {
                  var deceasedRest = Deceased.cast(deceased);
                  deceasedRest.remove()
                      .then(function(response){
                          if (response.status == 200) {
                              var index = _.findIndex(vm.lot.deceased, {id: parseInt(deceased.id)});
                              if(index > -1) {
                                  vm.lot.deceased.splice(index, 1);
                                  alertServices.showMessage('Deceased/Occupant Removed.', 'success');
                              }
                          }
                      });
              } else alertServices.showMessage('Cancelled', 'error');
            };

            alertServices.showPrompt('Deceased/Occupant', callback);
        }

        function cancel () {
            $mdDialog.cancel();
        }

        function computeLotAmount () {
            vm.lot.amount = parseFloat(vm.lot.price_per_sq_mtr) * parseFloat(vm.lot.lot_area);
        }

    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('clientSelectionController', ['$rootScope', '$scope', 'LOT_STATUSES', '$mdDialog', 'lot', 'clients', 'Clients', 'Lots', 'modalServices', clientSelectionController]);

    function clientSelectionController($rootScope, $scope, LOT_STATUSES, $mdDialog, lot, clients, Clients, Lots, modalServices) {
        var vm = this;

        vm.lot = null;

        vm.clients = clients;
        vm.client = {};
        vm.selectedClient = null;

        vm.lotParam = {
            status: {
                selected: '',
                showMenu: false,
                data: LOT_STATUSES.splice(0, 2)
            }
        };

        vm.initialize = initialize;
        vm.save = save;
        vm.cancel = cancel;
        vm.clearForm = clearForm;

        vm.initialize();

        /* Controller Functions here */

        function initialize() {
            console.log('lot client select controller initialized');

            // cleared data
            vm.rawClient = angular.copy(vm.client);

            vm.lot = lot;

            console.log('lot details: ', vm.lot);

            $scope.$watch(function(){
                return vm.dateSold;
            }, function(newValue, oldValue){
                if(!newValue || newValue === oldValue) return;

                var year = newValue.getFullYear(),
                    month = newValue.getMonth() + 1,
                    day = newValue.getDate();

                vm.lot.date_purchased = year + '-' + month + '-' + day;
            });
        }

        function save() {
            console.log('Select Client: ',vm.selectedClient);

            var promise = null;

            if( !$scope.selectClientDateForm.$valid) {
                // Show error messages
            } else {
                if (vm.selectedClient) {
                    // update lot with this client id
                    vm.lot.client_id = vm.selectedClient.client_id;
                    vm.lot.status = 'sold';
                } else {
                    if ($scope.newClientForm.$valid) {
                        vm.client.lot_id = vm.lot.id;
                        vm.lot.client = vm.client;
                    }
                }

                promise = vm.lot.customPUT(null, 'mark_sold');

                promise.then(function (response) {
                    console.log('Select Client: ', response);
                    $mdDialog.hide();
                    // TODO fetch new lot info via http request
                    if(!vm.lot.c_no)
                        $rootScope.$broadcast('update-lot-detail', {lot: Lots.cast(response.lot)});
                    else
                        modalServices.showColumbaryList();
                }, function (err) {
                    console.log('Error adding new client: ', err);
                });
            }
        }

        function cancel() {
            $mdDialog.cancel();
        }

        function clearForm() {
            console.log('clear form');
            vm.client = angular.copy(vm.rawClient);
            $scope.newClientForm.$setPristine();
        }

    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('layerController', [layerController]);

    function layerController() {
        var vm = this;

        vm.layers = [
            {
                label: 'Layer1',
                action: 'layerCtl.toggleLayer1()',
                selected: false
            },
            {
                label: 'Layer2',
                action: 'layerCtl.toggleLayer2()',
                selected: false
            },
            {
                label: 'LayerWithChildren1',
                action: '',
                selected: false,
                children: [
                    {
                        label: 'Child1-1',
                        selected: false,
                        action: ''
                    },
                    {
                        label: 'Child1-2',
                        selected: false,
                        action: ''
                    }
                ]
            },
            {
                label: 'LayerWithChildren2',
                action: '',
                selected: false,
                children: [
                    {
                        label: 'Child2-1',
                        selected: false,
                        action: ''
                    },
                    {
                        label: 'Child2-2',
                        selected: false,
                        action: ''
                    }
                ]
            }
        ];


        vm.toggleLayer1 = toggleLayer1;
        vm.toggleLayer2 = toggleLayer2;


        function toggleLayer1 () {
            if (vm.layers[0].selected) {
                console.log('turn on layer1');
            } else {
                console.log('turn off layer1');
            }
        }

        function toggleLayer2 () {
            if (vm.layers[1].selected) {
                console.log('turn on layer2');
            } else {
                console.log('turn off layer2');
            }
        }
        /* Non Scope Functions here */

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('indexController', ['$rootScope', '$mdSidenav', indexController]);

    function indexController ($rootScope, $mdSidenav) {
        var vm = this;

        // Show Treasure Overlay Spinner
        $rootScope.spinner = {
            active: false
        };

        vm.initialize = initialize;
        vm.toggleLayerPanel = buildToggler('layerPanel');
        vm.toggleSearchPanel = buildToggler('searchPanel');
        vm.closeSideNav = closeSideNav;

        vm.lastSideNavOpenId = '';

        vm.initialize();

        function initialize() {
            console.log('initialize called');
        }

        function buildToggler(navID) {
            return function () {
                if (vm.lastSideNavOpenId && vm.lastSideNavOpenId !== navID) {
                    closeSideNav(vm.lastSideNavOpenId);
                }

                $mdSidenav(navID).toggle();

                vm.lastSideNavOpenId = navID;
            }
        }

        function closeSideNav(navID) {
            $mdSidenav(navID).close();
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('gmapController', ['$scope', '$rootScope', 'gmapServices', 'LOT_COLORS', 'NAV_HEIGHT', gmapController]);

    function gmapController($scope, $rootScope, gmapServices, LOT_COLORS, NAV_HEIGHT) {

        var vm = this;

        vm.lotStatusFilters = {
          all: true,
          vacant: true,
          sold: true,
          occupied: true
        };

        vm.showLotLegend = true;
        vm.lotColors = LOT_COLORS;

        vm.getLotsCountByStatus = getLotsCountByStatus;

        $rootScope.spinner = {
            active: false
        };

        vm.initialize = initialize;
        vm.toggleLotLegend = toggleLotLegend;

        vm.initialize();

        function initialize () {
            gmapServices.createMap('map-canvas', NAV_HEIGHT);

            $scope.$watchCollection(function(){
                return vm.lotStatusFilters;
            }, watchLotStatusFilters);

        }

        function watchLotStatusFilters (lotStatusFilters, oldLotStatusFilters) {
            // All Lot Filters
            if(lotStatusFilters.all !== oldLotStatusFilters.all) {
                for(var key in vm.lotStatusFilters) {
                    if(key !== 'all') {
                        vm.lotStatusFilters[key] = lotStatusFilters.all;
                    }
                }

                $rootScope.$broadcast('toggle-lot-polygons', {status: 'all', value: lotStatusFilters.all});
                return;
            }

            for (var key in vm.lotStatusFilters) {
                if (lotStatusFilters[key] !== oldLotStatusFilters[key]) {
                    $rootScope.$broadcast('toggle-lot-polygons', {status: key, value: lotStatusFilters[key]});
                }
            }
        }

        function toggleLotLegend () {
            vm.showLotLegend = !vm.showLotLegend;
        }

        function getLotsCountByStatus (status) {

            return $rootScope.lotsDetail.count[status.toLowerCase()];
        }
    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('filterController', ['gmapServices', 'alertServices', filterController]);

    function filterController(gmapServices, alertServices) {
        var vm = this;

        vm.filterLayer = '';

        var searchMarker = null;
        var searchInfowindow = null;

        var autocomplete = null;

        vm.initialize = initialize;

        vm.initialize();

        /* Controller Functions here */

        function initialize() {
            autocomplete = gmapServices.initializeAutocomplete('filter-location-input');

            autocomplete.addListener('place_changed', placeChangeCallback);
        }


        //function showResult(data) {
        //    if (!searchInfowindow) searchInfowindow = gmapServices.createInfoWindow('');
        //
        //    if (!searchMarker) {
        //        searchMarker = gmapServices.createCustomMarker(data.coordinates);
        //    } else {
        //        if (!searchMarker.getMap()) gmapServices.showMarker(searchMarker);
        //
        //        searchMarker.setPosition(data.coordinates);
        //    }
        //
        //    searchInfowindow.setContent(data.content);
        //
        //    gmapServices.addListener(searchMarker, 'click', function () {
        //        searchInfowindow.open(gmapServices.map, searchMarker);
        //    });
        //
        //    gmapServices.triggerEvent(searchMarker, 'click');
        //}
        //
        //function hideSearchMarker() {
        //    if (searchMarker && searchMarker.getMap()) {
        //        gmapServices.hideMarker(searchMarker);
        //    }
        //}

        function placeChangeCallback() {
            var place = autocomplete.getPlace();
            if (!place.geometry) {
                alert("Autocomplete's returned place contains no geometry");
                return;
            }
            //console.log('Place Changed!', place);
            // If the place has a geometry, then present it on a map.
            if (place.geometry.viewport) {
                gmapServices.map.fitBounds(place.geometry.viewport);
            } else {
                gmapServices.map.setCenter(place.geometry.location);
                gmapServices.map.setZoom(15);
            }
        }


        /* Non Scope Functions here */

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('crematoriumListController', ['$rootScope', '$scope', '$mdDialog', 'Crematorium', 'modalServices', crematoriumListController]);

    function crematoriumListController ($rootScope, $scope, $mdDialog, Crematorium, modalServices) {
        var vm = this;

        $rootScope.cremations = [];
        vm.cremations = [];

        vm.query = {
            order: 'date_cremated',
            max_per_page: 10,
            page: 1,
            filter: ''
        };

        //vm.columbary = {
        //    pages: null
        //};

        vm.filter = {
            show: false,
            form: null
        };

        vm.searchFilters = {
        //    c_no: "",
        //    amount: "",
        //    status: "",
        //    client_name: ""
        };

        // Table Header
        vm.tableHeaderList = [
            'Date',
            'Name',
            'Sex',
            'Age',
            'Time Started',
            'Time Finished',
            'Gas Consumed (liters)',
            'Action'
        ];

        vm.initialize = initialize;
        vm.onReorder = onReorder;
        vm.removeFilter = removeFilter;
        vm.showDetails = showDetails;
        vm.newCremation = newCremation;
        vm.close = close;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            getData();

            $rootScope.$watchCollection('cremations', function(newCollection){
                if(newCollection.length <= 0) return;

                vm.cremations = newCollection;
            });

            //$scope.$watch(angular.bind(vm, function () {
            //    return vm.query.filter;
            //}), startFilter);
        }

        function getData() {
            Crematorium.getList()
                .then(function (list) {
                    console.log('cremations: ', list);
                    $rootScope.cremations = angular.copy(list);
                }, function (error) { console.log('error getting cremations list: ', error); });
        }

        //function startFilter() {
        //    vm.query.filter = vm.query.filter.toLowerCase();
        //    for (var key in vm.searchFilters) {
        //        if (vm.searchFilters.hasOwnProperty(key)) {
        //            vm.searchFilters[key] = vm.query.filter;
        //        }
        //    }
        //    filterList();
        //}
        //
        //function filterList() {
        //    vm.columbaryItems = isEmptyFilter()
        //                        ? columbaryServices.filterByBlock(vm.query.block)
        //                        : manualFilter(vm.searchFilters);
        //}
        //
        //function manualFilter(searchFilters) {
        //    var result = [];
        //    columbaryServices.columbaryList.forEach(function (c) {
        //        for (var key in searchFilters) {
        //            var data = String(c[key]).toLowerCase();
        //            if (data.indexOf(vm.query.filter) !== -1) {
        //                result.push(c);
        //                return;
        //            }
        //        }
        //    });
        //    return result;
        //}
        //
        //function isEmptyFilter() {
        //    return vm.query.filter === '';
        //}
        //
        /* Table Functions */

        function onReorder() {}

        function removeFilter() {
            vm.filter.show = false;
            vm.query.filter = '';

            if (vm.filter.form.$dirty) {
                vm.filter.form.$setPristine();
            }

        //    vm.columbaryItems = columbaryServices.filterByBlock(vm.query.block);
        }

        function showDetails (c) {
        //    modalServices.showColumbaryDetail(c)
        //        .finally(function(){
        //            $timeout(function(){
        //                modalServices.showColumbaryTable();
        //            });
        //        });
        }

        function newCremation () {
            close();
            $rootScope.showNewCremationFormPanel = true;
        }

        function close() {
            modalServices.closeModal();
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('cremationListReportController', ['$scope', '$mdDialog', 'BASE_URL', cremationListReportController]);

    function cremationListReportController ($scope, $mdDialog, BASE_URL) {
        var vm = this;

        vm.maxDate = new Date();

        vm.reportDate = {
          start: null,
          end: null
        };

        vm.reportDateData = {
            start: null,
            end: null
        };

        vm.initialize = initialize;
        vm.generateReport = generateReport;
        vm.cancel = cancel;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            $scope.$watch(function(){
               return vm.reportDate.start;
            }, function(newValue, oldValue){
                if(newValue === oldValue) return;
                vm.reportDateData.start = parseDate(vm.reportDate.start);
            });

            $scope.$watch(function () {
                return vm.reportDate.end;
            }, function (newValue, oldValue) {
                if (newValue === oldValue) return;
                vm.reportDateData.end = parseDate(vm.reportDate.end);
            });
        }

        function parseDate(date) {
            return date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate();
        }

        function getDatesForUrl () {
            return '?start='+vm.reportDateData.start+'&end='+vm.reportDateData.end;
        }

        function generateReport () {
            var datesUrl = getDatesForUrl();
            window.open(BASE_URL + '/reports/cremation_list' + datesUrl);
            $mdDialog.hide();
        }

        function cancel () {
            $mdDialog.cancel();
        }

        /* Non Scope Functions here */

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('columbaryTableController', ['$scope', '$mdDialog', 'columbaryServices', 'Columbary', 'modalServices', '$timeout', 'LOT_STATUSES', columbaryTableController]);

    function columbaryTableController ($scope, $mdDialog, columbaryServices, Columbary, modalServices, $timeout, LOT_STATUSES) {
        var vm = this;

        vm.statusChoices = [''].concat(LOT_STATUSES);

        vm.columbaryItems = [];

        vm.query = {
            order: 'c_no',
            max_per_page: 10,
            page: 1,
            filter: '',
            block: 'A',
            status: ''
        };

        vm.columbary = {
            pages: null
        };

        vm.filter = {
            show: false,
            form: null
        };

        vm.searchFilters = {
            c_no: "",
            amount: "",
            status: "",
            client_name: ""
        };

        // Table Header
        vm.tableHeaderList = [
            'Block',
            'Columbary No.',
            'Amount',
            'Status',
            'OR #',
            'Owner',
            'Date Purchased',
            'Action'
        ];

        vm.initialize = initialize;
        vm.onReorder = onReorder;
        vm.removeFilter = removeFilter;
        vm.showDetails = showDetails;
        vm.blockChange = blockChange;
        vm.statusChange = statusChange;
        vm.close = close;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            getData();

            $scope.$watch(angular.bind(vm, function () {
                return vm.query.filter;
            }), startFilter);
        }

        function getData() {
            columbaryServices.getAllData()
                .then(function (columbaryList) {
                    vm.columbaryItems = filterByBlock(columbaryList, vm.query.block);
                }, function (error) { console.log('error getting columbary: ', error); });
        }

        function filterByBlock (list, block) {
            return _.where(list, {block: block});
        }

        function startFilter() {
            vm.query.filter = vm.query.filter.toLowerCase();
            for (var key in vm.searchFilters) {
                if (vm.searchFilters.hasOwnProperty(key)) {
                    vm.searchFilters[key] = vm.query.filter;
                }
            }
            filterList();
        }

        function filterList() {
            vm.columbaryItems = isEmptyFilter()
                                ? columbaryServices.filterByBlock(vm.query.block)
                                : manualFilter(vm.searchFilters);
        }

        function manualFilter(searchFilters) {
            var result = [];
            columbaryServices.columbaryList.forEach(function (c) {
                for (var key in searchFilters) {
                    var data = String(c[key]).toLowerCase();
                    if (data.indexOf(vm.query.filter) !== -1) {
                        result.push(c);
                        return;
                    }
                }
            });
            return result;
        }

        function isEmptyFilter() {
            return vm.query.filter === '';
        }

        /* Table Functions */

        function onReorder() {}

        function removeFilter() {
            vm.filter.show = false;
            vm.query.filter = '';
            vm.query.status = '';

            if (vm.filter.form.$dirty) {
                vm.filter.form.$setPristine();
            }

            vm.columbaryItems = columbaryServices.filterByBlock(vm.query.block);
        }

        function showDetails (c) {
            modalServices.showColumbaryDetail(c)
                .finally(function(){
                    $timeout(function(){
                        modalServices.showColumbaryTable();
                    });
                });
        }

        function blockChange () {
            vm.columbaryItems = columbaryServices.filterByBlock(vm.query.block);
        }

        function statusChange () {
            vm.columbaryItems = vm.query.status
                                ? columbaryServices.filterByStatus(vm.query.status)
                                : columbaryServices.filterByStatus('', vm.query.block);
        }

        function close() {
            $mdDialog.hide();
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('columbaryListController', ['$scope', '$mdDialog', 'Columbary', 'modalServices', 'columbaryServices', columbaryListController]);

    function columbaryListController ($scope, $mdDialog, Columbary, modalServices, columbaryServices) {
        var vm = this;

        vm.tiles = [];
        var tempTiles = [];

        //vm.statusChoices = [''].concat(LOT_STATUSES);

        vm.query = {
            filter: ''
        };

        vm.filter = {
          form: null,
          block: 'A'
        };

        vm.searchFilters = {
            c_no: "",
            status: "",
            client_name: ""
        };

        vm.pages = {};

        vm.initialize = initialize;
        vm.changePage = changePage;
        vm.filterChange = filterChange;
        vm.showColumbaryDetail = showColumbaryDetail;
        vm.showColumbaryTable = showColumbaryTable;
        vm.removeFilter = removeFilter;
        vm.close = close;

        vm.initialize();

        function initialize () {
            columbaryServices.getAllData();
            getData();

            $scope.$watch(angular.bind(vm, function () {
                return vm.query.filter;
            }), startFilter);
        }

        function filterChange () {
            getData(vm.pages.page, vm.filter.block);
        }

        function showColumbaryDetail (c) {
            modalServices.showColumbaryDetail(c);
        }

        function getData(pageNo, block) {
            var _pageNo = pageNo || 1,
                _block = block ? block : null;

            columbaryServices.getData(_pageNo, _block)
                .then(function (response) {
                    vm.tiles = [];

                    if (response.columbary) {
                        response.columbary.forEach(function (item) {
                            vm.tiles.push(Columbary.cast(item));
                        });
                    }

                    tempTiles = angular.copy(vm.tiles);

                    if (response.pages) vm.pages = response.pages;

                }, function (error) { console.log('error getting columbary: ', error); });
        }

        function changePage (pageNo) {
            getData(pageNo, vm.filter.block);
        }

        function showColumbaryTable () {
            modalServices.showColumbaryTable();
        }

        function startFilter() {
            vm.query.filter = vm.query.filter.toLowerCase();
            for (var key in vm.searchFilters) {
                if (vm.searchFilters.hasOwnProperty(key)) {
                    vm.searchFilters[key] = vm.query.filter;
                }
            }
            filterList();
        }


        function filterList() {
            if (vm.query.filter === '') {
                getData();
            } else {
                vm.tiles = manualFilter(vm.searchFilters);
            }
        }

        function manualFilter(searchFilters) {
            var result = [];
            columbaryServices.columbaryList.forEach(function (c) {
                for (var key in searchFilters) {
                    var data = String(c[key]).toLowerCase();
                    if (data.indexOf(vm.query.filter) !== -1 && c['block'] == vm.filter.block) {
                        result.push(c);
                        return;
                    }
                }
            });
            return result;
        }

        function removeFilter() {
            vm.query.filter = '';

            //if (vm.filter.form && vm.filter.form.$dirty) {
            //    vm.filter.form.$setPristine();
            //}

            $scope.showFilterColumbary = false

            getData();
        }

        function close() {
            $mdDialog.cancel();
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('columbaryDetailsController', ['$scope', '$mdDialog', 'columbary', 'modalServices', columbaryDetailsController]);

    function columbaryDetailsController ($scope, $mdDialog, columbary, modalServices) {
        var vm = this;

        $scope.forms = {};
        $scope.buttons = {};

        vm.columbary = null;

        vm.columbary_copy = null;

        vm.initialize = initialize;
        vm.markSold = markSold;
        vm.addOccupant = addOccupant;
        vm.save = save;
        vm.cancel = cancel;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            vm.columbary = columbary;
            vm.columbary_copy = angular.copy(vm.columbary);
            console.log('columbary details: ', vm.columbary_copy);

            $scope.$watch(function () {
                return vm.columbary;
            }, function (newValue) {
                vm.columbary_copy = angular.copy(newValue);
            });
        }


        function markSold () {
            vm.columbary.status = 'sold';
            console.log('mark sold');

            modalServices.showClientSelection(vm.columbary)
                .then(function (success) {
                    console.log('ShowClientSelection: ', success);
                    vm.columbary.status = 'sold';
                }, function (err) {
                    console.log('ShowClientSelection: ', err);
                });
        }

        function addOccupant() {
            console.log('add occupant');
            // add functionality to update database
            modalServices.showAddOccupant(vm.columbary)
                .then(function (success) {
                    console.log('Show Add Occupant: ', success);
                }, function (err) {
                    console.log('Show Add Occupant: ', err);
                });
        }

        function save(event) {
            vm.columbary.save()
                .then(function(response){
                    console.log('updating columbary: ',response);
                    vm.columbary = response;
                    resetForms();
                    cancel(event);
                },function(error){
                    console.log('error updating columbary: ',error);
                });
        }

        function resetForms () {
            for(var key in $scope.forms) {
                $scope.forms[key] = false;
            }
            for (var key in $scope.buttons) {
                $scope.buttons[key] = true;
            }
        }

        function cancel (e) {
            $mdDialog.cancel()
                .finally(function(){
                    modalServices.showColumbaryList(e);
                });
        }
    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('blockDetailsIndexController', ['$rootScope', '$mdSidenav', 'sectionList', 'blockList', 'lotList', 'gmapServices', 'drawingServices', blockDetailsIndexController]);

    function blockDetailsIndexController ($rootScope, $mdSidenav, sectionList, blockList, lotList, gmapServices, drawingServices) {
        var vm = this;

        vm.lastPolygon = null;

        vm.editMode = false;
        vm.tempBlock = {
            name: null,
            polygon: null,
            area: []
        };

        var saveListener = {
            lot: null
        };

        vm.block = {
          id: '',
          name: '',
          lots: [],
          area: []
        };

        vm.blockInfo = {
            lotCount: 0,
            soldLot: 0,
            unsoldLot: 0
        };


        vm.initialize = initialize;
        vm.close = close;
        vm.onLotClick = onLotClick;
        vm.showBlock = showBlock;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            $rootScope.$on('show-block-details', function(event, params){
                console.log('show block details event ', params.block);
                vm.editMode = false;
                vm.block = params.block;
                vm.tempBlock.name = params.block.name;

                updateBlockDetails(vm.block);

                gmapServices.hidePolygon(vm.block.polygon);

                if(vm.lastPolygon) {
                    gmapServices.setEditablePolygon(vm.lastPolygon, false);
                    gmapServices.showPolygon(vm.lastPolygon)
                }

                vm.lastPolygon = vm.block.polygon;

                if(vm.tempBlock.polygon) {
                    gmapServices.hidePolygon(vm.tempBlock.polygon);
                    vm.tempBlock.polygon = null;
                }

                vm.tempBlock.polygon = gmapServices.createCustomPolygon(vm.block.area, blockList.polygonOptions);
            });
        }

        function resetBlockInfo() {
            for (var key in vm.blockInfo) {
                vm.blockInfo[key] = 0;
            }
        }

        function updateBlockDetails (blk) {
            resetBlockInfo();

            vm.blockInfo.lotCount += blk.lots.length;
            vm.blockInfo.soldLot += _.where(blk.lots, {status: 'sold'}).length;
            vm.blockInfo.soldLot += _.where(blk.lots, {status: 'occupied'}).length;
            vm.blockInfo.unsoldLot += _.where(blk.lots, {status: 'vacant'}).length;
        }

        /* Section Functions */

        function editSection () {
            toggle(true);
        }

        function saveChanges () {
            toggle(false);
            vm.tempSection.area = drawingServices.getPolygonCoords(vm.tempSection.polygon);

            // to avoid this error "TypeError: Converting circular structure to JSON"
            vm.section.polygon = null;

            vm.section.area = vm.tempSection.area;
            vm.section.name = vm.tempSection.name;

            vm.section.put()
                .then(function(response){
                    gmapServices.hidePolygon(vm.tempSection.polygon);
                    vm.tempSection.polygon = null;
                    vm.lastPolygon = null;

                    vm.section.polygon = gmapServices.createCustomPolygon(vm.section.area, sectionList.polygonOptions);

                }, function(error){
                    console.log('failed updating section: ',error);
                });
        }

        /* End Section Functions */


        /* Block Functions */

        function showBlock(block) {
            gmapServices.setZoomIfGreater(21);
            gmapServices.panToPolygon(block.polygon);
        }

        /* End of Block Functions */

        /* Lot Functions */

        function onLotClick(lot) {
            var foundLot = lotList.findLot(lot.block_id, lot.id);
            if (foundLot) gmapServices.triggerEvent(foundLot.polygon, 'click');
        }

        /* End of Lot Functions */


        function toggle(flag) {
            vm.editMode = flag;
            gmapServices.setEditablePolygon(vm.tempSection.polygon, flag);
        }

        vm.openBlockMenu = openBlockMenu;
        var originatorEv;

        function openBlockMenu($mdOpenMenu, ev) {
            originatorEv = ev;
            $mdOpenMenu(ev);
        };

        function close () {
            $mdSidenav('blockDetailsIndexSidenav')
                .close()
            ;
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('adminGmapController', ['$rootScope', 'gmapServices', adminGmapController]);

    function adminGmapController($rootScope, gmapServices) {

        var vm = this;

        $rootScope.spinner = {
            active: false
        };

        vm.initialize = initialize;

        vm.initialize();

        function initialize () {
            gmapServices.createMap('admin-map-canvas', 0);
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('adminController', ['$rootScope', '$scope', 'Sections', 'drawingServices', 'modalServices', 'sectionList', adminController]);

    function adminController ($rootScope, $scope, Sections, drawingServices, modalServices, sectionList) {
        var vm = this;

        // drawing tools
        vm.drawBtn = {
          save: false,
          delete: false,
          cancel: false
        };

        // save listeners
        var saveListeners = {
            section: null
        };

        $rootScope.sections = [];

        vm.initialize = initialize;

        vm.addSection = addSection;

        vm.stopDrawing = stopDrawing;
        vm.saveArea = saveArea;
        vm.deleteSelected = deleteSelected;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            sectionList.loadSections();

            $rootScope.$on('start-drawing', function(){
               vm.drawBtn.cancel = true;
            });

            $rootScope.$on('overlay-complete', function () {
                $scope.$apply(function(){
                    vm.drawBtn.save = true;
                    vm.drawBtn.delete = true;
                });
            });

            $rootScope.$on('duplicate-complete', function () {
                $scope.$apply(function () {
                    vm.drawBtn.cancel = true;
                    vm.drawBtn.save = true;
                });
            });

            $rootScope.$on('end-drawing', function(){
                terminateButtonsAndListeners();
            });
        }

        function addSection (ev) {
            startDrawing();

            saveListeners.section = $scope.$on('save-area', function(event, param){
                modalServices.showAddSection(ev, param.area)
                    .then(function(result){
                        // Restangularized Object
                        Sections.get(result.section.id)
                            .then(function (response) {
                                sectionList.add(response);
                            });
                    }, function(reason){
                        console.log('failed: ',reason);
                    })
                    .finally(function(){
                        saveListeners.section();
                        saveListeners.section = null;
                    });
            });
        }

        function saveArea() {
            if (drawingServices.duplicateLotPolygon) {
                var _path = drawingServices.getPolygonCoords(drawingServices.duplicateLotPolygon);
                $rootScope.$broadcast('save-duplicate', {path: _path});
                vm.stopDrawing();
                return;
            }

            if (drawingServices.updateLotPolygon) {
                var _path = drawingServices.getPolygonCoords(drawingServices.updateLotPolygon);
                $rootScope.$broadcast('save-lot-polygon', {path: _path});
                //vm.stopDrawing();
                return;
            }

            if (!drawingServices.overlay) {
                alert('Cannot proceed. No Overlay Drawn.')
                return;
            }

            var area = drawingServices.overlayDataArray;

            $rootScope.$broadcast('save-area', {area: area});

            vm.stopDrawing();
        }

        function deleteSelected() {
            if (drawingServices.overlay) {
                drawingServices.clearOverlay();
                vm.drawBtn.save = false;
            }
        }

        function terminateButtonsAndListeners () {
            drawingServices.destroyUpdateLotPolygon();
            drawingServices.destroyDuplicateLot();
            drawingServices.stopDrawingMode();

            // hide draw buttons
            for (var key in vm.drawBtn) vm.drawBtn[key] = false;

            // destroy save listeners
            for (var key in saveListeners) {
                if (saveListeners[key]) {
                    saveListeners[key]();
                    saveListeners[key] = null;
                }
            }
        }

        function stopDrawing () {
            $rootScope.$broadcast('stop-drawing');

            terminateButtonsAndListeners();
        }

        /* Non Scope Functions here */

        function startDrawing () {
            drawingServices.startDrawingMode();
            // Show Cancel Map button
            vm.drawBtn.cancel = true;
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('addSectionController', ['$mdDialog', 'area', 'Sections', addSectionController]);

    function addSectionController ($mdDialog, area, Sections) {
        var vm = this;

        vm.section = {
            area: area,
            name: ''
        };

        vm.save = save;
        vm.cancel = cancel;

        /* Controller Functions here */

        function save () {
            Sections.post(vm.section)
                .then(function(response){
                    $mdDialog.hide(response);
                }, function(error){
                    console.log('Error: ', error);
                    // Show Errors
                });
        }

        function cancel () {
            $mdDialog.cancel();
        }

    }
}());
(function () {
    'use strict';

    angular.module('demoApp')
        .controller('addLotOccupantController', ['$rootScope', '$scope', '$mdDialog', 'lot', 'modalServices', addLotOccupantController]);

    function addLotOccupantController($rootScope, $scope, $mdDialog, lot, modalServices) {
        var vm = this;

        vm.lot = null;
        vm.occupant = {};

        vm.initialize = initialize;
        vm.save = save;
        vm.cancel = cancel;
        vm.clearForm = clearForm;

        vm.initialize();

        $scope.maxDate = new Date();

        /* Controller Functions here */

        function initialize() {
            vm.lot = lot;
            console.log('lot details: ', vm.lot);
        }

        function save() {
            if($scope.newForm.$valid) {
                vm.lot.post('deceased', vm.occupant)
                    .then(function (response) {
                        console.log('New Deceased: ', response);
                        $mdDialog.hide();
                        // TODO fetch new lot info via http request
                        vm.lot.status = 'occupied'; // TODO extract to constant

                        if (!vm.lot.c_no)
                            $rootScope.$broadcast('update-lot-detail', {lot: vm.lot});
                        else
                            modalServices.showColumbaryList();
                    }, function (err) {
                        console.log('Error adding new deceased: ', err);
                    });
            }
        }

        function cancel() {
            $mdDialog.cancel();
        }

        function clearForm() {
            vm.occupant = {};
            $scope.newForm.$setPristine();
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('addLotController', ['$scope', '$mdDialog', 'block', 'area', 'Blocks', 'alertServices', 'lotHelper', 'sections', addLotController]);

    function addLotController ($scope, $mdDialog, block, area, Blocks, alertServices, lotHelper, sections) {
        var vm = this;

        vm.block = null;

        vm.lot = {
            //block_id: block.id,
            area: area,
            dimension_width: 0,
            dimension_height: 0,
            lot_area: ''
        };

        vm.sections = sections;
        vm.sectionBlocks = [];

        vm.selectedSectionId = null;
        vm.selectedBlockId = null;

        vm.initialize = initialize;
        vm.save = save;
        vm.cancel = cancel;

        vm.initialize();

        /* Controller Functions here */

        function initialize () {
            // Restangularized
            if(block) {
                vm.lot.block_id = block.id;
                vm.block = Blocks.cast(block);
            }

            $scope.$watch(function () {
                return vm.lot.dimension;
            }, function (newValue, oldValue) {
                if (newValue == oldValue) return;
                computeLotArea(newValue);
            });

            $scope.$watch(function(){
                return vm.selectedSectionId;
            }, function(newValue, oldValue){
                if(!newValue || newValue === oldValue) return;
                var foundSection = _.findWhere(vm.sections, {id: parseInt(newValue)});
                if(foundSection) vm.sectionBlocks = foundSection.blocks;
            });

            $scope.$watch(function () {
                return vm.selectedBlockId;
            }, function (newValue, oldValue) {
                if (!newValue || newValue === oldValue) return;
                var foundSection = _.findWhere(vm.sections, {id: parseInt(vm.selectedSectionId)});
                if (foundSection) {
                    var foundBlock = _.findWhere(foundSection.blocks, {id: parseInt(newValue)});
                    if(foundBlock) {
                        vm.lot.block_id = foundBlock.id;
                        vm.block = Blocks.cast(foundBlock);
                    }
                }
            });
        }

        function computeLotArea(dimension) {
           var result = lotHelper.computeArea(dimension);

            vm.lot.dimension = result.dimension;
            vm.lot.lot_area = result.area;
        }

        function save () {
            vm.lot.dimension = lotHelper.filterDimensionString(vm.lot.dimension);

            if(vm.block) {
                vm.block.post('lots', vm.lot)
                    .then(function (response) {
                        $mdDialog.hide(response);
                        alertServices.showLotAdded();
                    }, function (error) {
                        console.log('Error: ', error);
                        alertServices.showErrorMessage(error.data.message);
                    });
            } else {
                alertServices.showErrorMessage('Please Select Block');
            }
        }

        function cancel () {
            $mdDialog.cancel();
        }

    }
}());
(function(){
'use strict';

angular.module('demoApp')
    .controller('addBlockController', ['$mdDialog', 'section', 'area', addBlockController]);

    function addBlockController ($mdDialog, section, area) {
        var vm = this;

        vm.block = {
            area: area,
            name: ''
        };

        vm.save = save;
        vm.cancel = cancel;

        /* Controller Functions here */

        function save () {
            //if (typeof section.addBlock == 'function') {

            section.addBlock(vm.block)
                .then(function(response){
                    $mdDialog.hide(response);
                }, function(error){
                    console.log('Error: ', error);
                });

            //} else {
            //    console.log('function section.addBlock doesnt exist!');
            //}
        }

        function cancel () {
            $mdDialog.cancel();
        }

    }
}());
(function(){
    'use strict';

    var lotStatuses = [
        'vacant',
        'sold',
        'occupied'
    ];

    var lotStatusJson = {
        VACANT: 'vacant',
        SOLD: 'sold',
        OCCUPIED: 'occupied'
    };

    var lotColorByStatus = {
        vacant: '#2ecc71',
        sold: '#e74c3c',
        occupied: '#9b59b6'
    };

    var lotDimensions = [
        '3 X 3',
        '3 X 4.5',
        '1.5 X 3',
    ];

    angular.module('demoApp')
        .value('LOT_STATUSES', lotStatuses)
        .value('LOT_STATUSES_JSON', lotStatusJson)
        .value('LOT_DIMENSIONS', lotDimensions)
        .value('LOT_COLORS', lotColorByStatus)
    ;

}());


